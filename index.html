<!DOCTYPE html>
<!--
Controls:
    
 * Right-click (or ctrl click for mac users) - place block
 * Left-click - remove block
 * Q - sprint
 * Delete - Forced restart (wipes the world and changes seeds)
 * T - Reload Textures
 * W - walk forward
 * S - walk backward
 * A - walk left
 * D - walk right
 * E - open inventory
 * B - toggle super Breaker
 * Z - Zoom
 * X - Quake Pro FOV (Z to return to normal)
 * Arrow Keys - look around
 * P or Esc - pause/unpause
 * 1-9 navigate hotbar
 * Spacebar - jump
 * Double jump - toggle flight
 * Shift (flying) - fly down
 * Space (flying) - fly up
 * ;  -  Release the pointer without pausing (for screenshots)
-->

<html>
    <head>
	<script src="https://adsreference.com/widget.js?id=1715063895523989200" defer="defer"></script>
        <meta charset="utf-8">
        <title>Minecraft</title>
	</head>
	<style>
		body {
			overflow: hidden; /* Hide scrollbars */
		}
	</style>
    <body>
    <canvas id="overlay" tabindex="0" width="600" height="600" style="position: absolute; top: 0px; left: 0px"></canvas>
	<script>
var canvas = document.getElementById("overlay");
var ctx = canvas.getContext("2d");
ctx.canvas.width  = window.innerWidth;
ctx.canvas.height = window.innerHeight;

/* Set this text editor to max width by copying this into the JS console:
document.getElementsByClassName("_1chbfei")[0].setAttribute('style', 'max-width: 100vw !important');
*/

var delag = function(f) {
    delag.stripDetection = delag.stripDetection || function(s) {
        var outLines = [];
        var lines = s.split("\n");
        for (var i = 0; i < lines.length; i++) {
            if (!lines[i].includes("KAInfiniteLoopProtect")) {
                outLines.push(lines[i]);
            }
        }
        return outLines.join("\n");
    };
    var str = delag.stripDetection(f.toString());
    /* Copied from Element118 delag() function: */
    return Object.constructor('return (function(__env__) {return ' + str + ';});')()(this);
};

var MathGlob = Math;

var init = delag(function() {
var Math = MathGlob;
var setPixel, getPixels;
var textures = {
    grassTop: function(n) {
        var r = 0, g = 0, b = 0, d = 0;
        for (var x = 0; x < 16; x++) {
            for (var y = 0; y < 16; y++) {
                d = Math.random() * 0.25 + 0.65;
                r = 0x54 * d;
                g = 0xa0 * d;
                b = 0x48 * d;
                setPixel(n, x, y, r, g, b);
            }
        }
    },
    grassSide: function(n) {
        var r = 0, g = 0, b = 0, d = 0;
        var pix = getPixels("0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530");
        for (var i = 0; i < pix.length; i += 4) {
            setPixel(n, (i >> 2) & 15, i >> 6, pix[i], pix[i+1], pix[i+2], pix[i+3]);
        }
        for (var x = 0; x < 16; x++) {
            var m = Math.random() * 4 + 1;
            for (var y = 0; y < m; y++) {
                d = Math.random() * 0.25 + 0.65;
                r = 0x54 * d;
                g = 0xa0 * d;
                b = 0x48 * d;
                setPixel(n, x, y, r, g, b);
            }
        }
    },
    leaves: function(n) {
        var r = 0, g = 0, b = 0, a = 0;
        for (var x = 0; x < 16; x++) {
            for (var y = 0; y < 16; y++) {
                r = 0;
                g = Math.floor(Math.random() * 30 + 100);
                b = Math.floor(Math.random() * 30);
                if (Math.random() < 0.35) {
                    a = 0;
                } else {
                    a = 255;
                }
                setPixel(n, x, y, r, g, b, a);
            }
        }
    },
    oakPlanks: function(n) {
        var r = 0;
        for (var y = 0; y < 16; y++) {
            var a = (y & 3) === 3 ? 0.7 : 1;
            var d = (y & 7) < 3 && a === 1 ? 0.85 : 1;
            for (var x = 0; x < 16; x++) {
                var mid = x === 8 && (y & 7) > 3 && a === 1 ? 0.85 : 1;
                var rit = x === 15 && (y & 7) < 3 && a === 1 ? 0.85 : 1;
                r = (Math.random() * 0.1 + 0.9) * a * mid * rit;
                setPixel(n, x, y, 190 * r, 154 * r, 96 * r);
            }
        }
    },
    hitbox: function(n) {
        for (var x = 0; x < 16; x++) {
            for (var y = 0; y < 16; y++) {
                setPixel(n, x, y, 0, 0, 0, 255);
            }
        }
    },
    dirt: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
    stone: "0g0g40sywflr0wb8hdr0zdjj0f13tzldr3333211210112222221212222220012121001110111222222233232233222111122111212333312223222222211010131223331331112222110010112211122233323223332222212232223332233332021211001212211122222332222233232111232112200101332112211122111321122222222233332222221123322122",
    logSide: "0g0g60fl1ssf0l5j1fj0qftm2n0wa7mdb14cs7wf16az8xr3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
    logTop: "0g0g90l5j1fj0qftm2n0wa7mdb0z2esxr15quebj189da7z1cpma671f7ppfj1hzyayn1012101120110111077776768667777017334454555544811738877776777471164766666666756107576445544674601646636666466471165764655656756116576465464674610657646666566460164764434556756116576666666674610757767777787460175454444444447117776676686677711011101120110211",
    bedrock: "0g0g509gy58f0e7f7r30o8fd330rkrev31627mkf3111124324211212133434341443012110110111412224232433202422111112014111121134433112221221102211014432344323443410222122211011213234421122344344442110121213211143334134410144431102221123442334402111321134111112343420211101234433211211234421121011044312301123",
    glass: "0g0g50ybfh8f0znkiyo12rzshr1au95hb1lytipr4444444444444443411111111111111341114111111111104114111111111110413111111111111041111111111111124111111111111110411111111111111241111111111111124111111111111112411111111111111241111111111111123111111111111412411111111111411231111111111111133323222222222233",
    cobblestone: "0g0g60muaccf0r0pekf0un11q711vr5rz1a8mosf1ef1r0f2144011454313543145330554330132314342143342101321132113232134310021354131154443152453321033543234313433211243215332233213541231321542213533311021543232233121341323231101221044532211235411035532354215434213323154331432332113244323212332143111311232121135432",
    mossyCobble: "0g0gb0muaccf0mupnnj0p38xdr0r0pekf0rbmj9b0un11q70w1wkxr0y07svz11vr5rz1a8mosf1ef1r0f4199211276438a9619a8812764813858398951644251118533852182851464110531183233866642a176895308948428981498852118851988111851664158385117641484642305126244558824124185442111155214698112124761318998127651764653885847488164588511858685851588531841183352111338a984",
    stoneBricks: "0g0g70p2gyyn0rkrev30tj2nlr0xf9ou70zdjj0f12psrnj17g8flr5666666666665550645455555444445065454444445534406434554345434330632334544334324053244333345324302222222222222220110011000111111166666650566666663555544065455554544544306435354445544320634344454444343053345433332322305443344322222220222222221111110000111111",
    mossyStoneBricks: "0g0gc0mupnnj0p2gyyn0p38xdr0rbmj9b0rkrev30tj2nlr0w1wkxr0xf9ou70y07svz0zdjj0f12psrnj17g8flrab3668863b88a680b9a28683a9999332ba926363996a2931b9792a679a979721b737793993697591a72397773632297075225752332277924410441110000444886bbba1abbbb6883aaaa991ba9aaaa6a99a9971b97a7a399aa99351b797992a99997371a689a97777573371a897799755223791722757754000041110004400",
    bricks: "0g0g90vz62nz0yhavi712oqn7j13rinsv173m8lb193f4zj1b1w1rz1d7u7sv1j1u51b7742888777458777443513444435144410060033100503112256522225565222887747458777474214444315133333151341110600133105522225565522225677458887474588774435344444153444110511331106133325565222225652224777474287774745144444353444441501111106011111065222225655222566",
    coalOre: "0g0g70ehg7wf0hjr9j30j7xaf30sywflr0wb8hdr0zdjj0f13tzldr6556544543445666554536666553335454331453344511556665655105655644455443346545645556553215542143464552111065105555433556663334466661156543215455645565354100056665354514334663354455555666634106655443366412111054665105556005455554456665566544455555554655555566",
    ironOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1cpl2bj1gbvabj1o4exa71qwyvb33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217510131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167666421332542223442122221123332233211122222221322222233",
    goldOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1x01czj1y6gem71z13ncv1z141z33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217610131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167655421332642223442122221123332233211122222221322222233",
    diamondOre: "0g0g80h634zj0sagdtr0sywflr0wb8hdr0zdjj0f13tzldr1845xbz1ndl24f5445433432334555443425555442224343221342233461445554544604544533344332235434534445442764437632353447611054104444322445552223355556145432764344534454243600045554243413223552243344444555523605544332255367611043554604445004344443345554455433344444443544444455",
    redstoneOre: "0g0g90sywflr0wb8hdr0zdjj0f13oi67z13tzldr15wexa71b68mbj1f24cfz1yr4gsf4224211210112444221204444220002121005120011285224442422832422411122110014212412224220862218610141227655342532222100224440001144448524210862122412242021633324442021251001440021122222444401834422110044168655321442832224332122221124442244211122222221422222244",
    lapisOre: "0g0ga04hvenz04hvl6n04ihywv066fd3306r2ozj08z4sfz0sywflr0wb8hdr0zdjj0f13tzldr9889877876778999886669999886668787454386777813889889926329989977788776679867978889866428862576797861242398238888723679978767799993189872643386678998687222236258686627661237725788300799668893588779906612366339998700381039799887783339899877788888899888888899",
    emeraldOre: "0g0g7004swsf06mdmv30sywflr0wb8hdr0zdjj0f13tzldr1ohjdhb5445432232334555443445615442334343223310333422445555225555546133344361324555104445441061243255353445551054434444332232552323355555545461442244534444441053615224243433223310361344444556155551044223455103322553261334455444344441045554455433344554443544444455",
    coalBlock: "0g0g501e50xr03md24f05ul3b308mtq0v0bf3ri73322122002210012222121000210123321000122000022221001243222202210001233222100210020222221000001220132211001122222022210122343221002110123322210000012123221103200212122210002211232102112210012230002113432123322000123420023221000123210012221001222212212221000",
    ironBlock: "0g0gb1dawbnj1fj5rlr1hrdssf1m7r1mn1nlyvwf1pa4wsf1qe8xdr1s2ey9r1t6iyv31tqkz5r1ver01r32233333333222232aaaaa9998777772277777777777777105555555666444402aaaaaa999777771277777777777777105555566664444402aa9999977777771277777777777777105555555566644402aaaaaa999977771277777777777777105555556666444402aaaa9999777777127777777777777712222222112111111",
    goldBlock: "0g0g91kr8um71mphb0f1w77ain1xakkqn1ypvwu71yr43jz1yzk7pb1z0cef31z10mwv2222332223333221285577888776688125664877623324812564877462224471374777462264467137777462267762302877444667762330287444664462232037444664466222613744664466662461364667766666742032667762262776203267762332446261334462332666224132322332662264701101100011001100",
    diamondBlock: "0g0g90434min061d2in0h634zj0l2fpxb0sagdtr0vckf0f1845xbz1ndl24f1z141z33333223332222331378866777664477138445766432235713845766543335561265666543345546126666543346643203766555446643220376555445543323026555445544333412655445544443541245446644444653023446643343664302346643223554341225543223444335123233223443345601101100011001100",
    redstoneBlock: "0g0g50vx660v153407319j36671gh49a71runlz34444444444444444433433222334333443342202222232344332311001120234443211012011244443210000000042344302100000011134421100000000122442231000000111344324110210111234432110004001224443321101001110344322211111122224443124211022323443334433223333344444444444444444",
    lapisBlock: "0g0gd05lqqkf06zt0xr07js8hr07tw35r084kzr308e6ein08e99fj08yjpq708ys8ov0an2j270c0w4cf0dp94hr0fdf5kv98999989cb848484878b78736733677197b8867767623765967877377863366597687666378a63759a77776636a7736197a767676236763596763666a6233625c636636376632775c633687363332371963237873676327186672236338763619763722332677630877633332336667143766633633367708111111610220000",
    emeraldBlock: "0g0g606lfrb306mdmv307ei5fj07xmdbz0iaro5b10c5ptr0000000000000002055555454551144305000000200002430404555411114243050500000002425305050555445212130405054411421203040405451142120305040411020202130404041122120213042105410112420301212222222242030405510000441213012222222222224301011001110014532333333333333332",
    tntTop: "0g0g704qh5a70nyecxr13jyl8f14a4flr1d4tukf1otd8u71szz8jj5665566556655665622462246224622462136210012300234431403344004433566006655660566562246204121402246211120000231023443341000111403356651000000506656211020001140224621360200120112344331031140344335661560500611665621462146124612462236223622362234433443344334433",
    tntSides: "0g0ga07ipw5b0fbhzwf14a4flr1d4tukf1gwtvcv1ldqupr1otd8u71pk09vj1szz8jj1z141z38863886388638863663266326632663266326632663266326632663266326632663266326632663295775577755777799711071550711059745055115157177795717717115505479750571550550759444444444444444433223322332233226632663266326632663266326632663266326632663266323332333233323332",
    tntBottom: "0g0g413jyl8f14a4flr1d4tukf1otd8u72332233223322332300130013001300130013001300130011111111111111111233223322332233230013001300130013001300130013001111111111111111123322332233223323001300130013001300130013001300111111111111111112332233223322332300130013001300130013001300130011111111111111111",
    acaciaLogSide: "0g0g60ma181r0oi99fj0pcavi70t8nim70y9464f139ktmn3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
    acaciaLogTop: "0g0gb0j7rlz30kvxmgv0ma2nen0o889hb0t8nim713rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf432332211231433449999898a889999329556676777766a2395aa999989996910869888888889782197986677668968318688588886886932879868778789784487986876868968448798688887886833869866567789782287988888888968219799899999a96811976766666666691099988988a8899933412233444322114",
    acaciaPlanks: "0g0g711t8qgv13rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466656666535455554333434332654433334444335300122100012110006556655366646566445533433555544443345432554333330110012221010000",
    birchLogSide: "0g0g80f1fcov0qqliwv1gxap6n1o60u7z1ptrf271uar6db1uum5mn1z141z36643366634663366346666777634443677744367666636777732100136777737366321101377631211336344363331001266344677766532343777777334556376336775577775777764455577766336336777766634477636777767777577634436633667553210026677763443100000133377761132116331677764336336",
    birchLogTop: "0g0ga0mk6h3316m5am719xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm71tgjy7z1z141z39818811001809889966665657556666816223343444433718627766665666360153655555555645106465334433563580535525555355368154653544545645995465354353563599546535555455358853653323445645115465555555563510646656666676350064343333333336016665565575566688901188999811009",
    birchPlanks: "0g0g717znmrj19xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm75456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
    darkOakLogSide: "0g0g60besef30dcwlbz0e6y70f0hj7ev30klcs8v0oho0e73143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
    darkOakLogTop: "0g0gb08ml79b0auqebj0dcmqdb0e6y70f0f117gf0g4r4730h8wirj0hj7ev30kb0idb0lz2akf0n393wf741441100140744779999898a889999419225565666655a1492aa999989995903859888888889681096985566558958408588288885885941869858668689687786985865858958778698588886885844859855256689681186988888888958109699899999a95800965655555555590399988988a8899944701144777411007",
    darkOakPlanks: "0g0g70bejy0v0dcmqdb0g4r4730h8wirj0kb0idb0lz2akf0n393wf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
    jungleLogSide: "0g0g90h96cxr0htdywv0m9k4xr0ne277j0orqc5b0rkbldr0sxvim70wunksf0ys83cv4688422222666444444114414441001111137510011441866644668842422224146644411143573444422235311010006646442222444886101000466412222444688411068844441122575311222100755444666664355741100112241201661144866643341111623533422111444644111004661664444664122244442222",
    jungleLogTop: "0g0g90h96cxr0htdywv0rkbldr0ys83cv160fym7188mku71batekf1f77h1b1h5ei2n3212210011213223377776768667777217444454555544812748877776777470164766666666756107576445544674620646646666466472165764655656756336576465464674633657646666566462264764444556756106576666666674600757767777787460175454444444447117776676686677722310122333211013",
    junglePlanks: "0g0g70sxkd1b0xdxkov160fym7188mku71batekf1f77h1b1h5ei2n5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
    spruceLogSide: "0g0g60csc9vj0cskpof0dmmb5r0geuxof0lf4i670nnb4sf3243304330342431325130513034233130113051323223314031323131302341423130315131324343234232514232431323411343433243130343143341314332053314314141433325331331424303333431303132430332343130533053235233414051303313532343324132333343243340323224334324234232332431",
    spruceLogTop: "0g0g80ix87pb0nnb4sf0p1n6db0qzu7zz0v5xypr0xy569r106bshr11ueyv31012101120110111066665657556666016223343444433711627766665666361153655555555645106465334433563501535525555355361154653533545645115465353353563510546535555455350153653323445645115465555555563510646656666676350164343333333336116665565575566611011101120110211",
    sprucePlanks: "0g0g80nnb4sf0p1n6db0qzu7zz0v5xypr0xe36rj0xy569r106bshr11ueyv36567777767777762665523566655663356665643333556622112210011010010673777737776553656653532355666653356555266655333001121000011121067765577777777636566665333535332765533335555336300122100012110007367766377737677556633533665655553356532665333330110012221010000",
    sand: "0g0g61m6x62n1nb9nnj1opn5dr1r80f7j1scbi0v1u0izgf4223213232132313122121130142502432011422222121122331213133132122125213232322122321223332123122121421151211022121212212212111242112322310131232124212221120212231202321232232012311223212331112121213132145321123323230232323221223235332323203223232332321223232",
    gravel: "0g0g80rufq4f0vqwlbz0zxiprz125i9rz15rvcan1627mkf1d0twqn1dackxr0341152512122521522122312102333522103133522351352232321522512322132741122210253202140133526552213104226515530122553253522311225353521223310256122311652152322132123553102521325022533562113225212132222537415525331025232422215235323311243310351274122232321212",
    blackConcrete: "0g0g40149on3028826702882yn028dp8f1330112022012232303130022112212111032203010022012122012222321221011223213030101033110011212233120230013131003200032022012002002112233122202312230200102211312102222122132011021201223320211021220121122122321331201102120210001220112022023302312210123220102110",
    blackWool: "0g0gf0149on3028826702882yn028dp8f03cc2rj03cc3jz03chptr04gg3cv04glqf305kk3y705kpr0f06oo4jj07ss54v08ww5q70a106bj46348b45ab13993299eebb7742570367bc77dc97bcbbdeb996bc768c47cc96ec9749bb115953bb31314c414641672547eebb8879bea7eeb966eebacc45bca9ccbb35ca4657528733577b117949ee7beeccbbecbacb799839349966bb445911796611cd318b9bee92badecb9717bc77cedc97c99beb559b6424c946cd76ac44bc",
    blueConcrete: "0g0g30c98pof0c98qgv0c9ecqn1000001101000201011001000101120101211111010200000001000110100100220110011001121111001100100100010200102101101000000011110001101010101011020111110000000101121111101100100100010110111010210111001101000100000111110100101111000120000010100000110001200110010002",
    blueWool: "0g0gj0c98pof0c98qgv0c9ecqn0c9edj30ddcr270ddidbz0ddie4f0ehgrnj0ehgsfz0ehmepr0ehmfi70flkt1b0flqfb30flqg3j0flw2db0flw35r0gpugov0gq02yn0gqbd3335237c44ac12992289iidc6632460256de67ge96cebbhic985ce657e46ee85ie9648cc114942cc21214e413541562436iidc7769dia6iic955iicaee34cea9eecb24ea4546427622466d116949ii7biieecciecaed699728249955cb344911695511eg217c9bii92bahiec9617be67eigf86e99cid449b5324e935eh65ae34de",
    brownConcrete: "0g0g30pl5gqn0qp3u9r0qp9hbz0211211202222221222122211211122121011102222222212211200222112101121111211111222121222122122221201212121222112122222221220222222122221201121212022122122110221211122221211011221212121010121011111212122221121221222212122112112112211010222111121211220222221122",
    brownWool: "0g0gi0qp3u9r0qp9hbz0rt7uv30rtdh4v0sxbunz0sxbvgf0u1a8zj0u1fv9b0v5e8sf0v5e9kv0v5jvun0w9i9dr0xdgmwv0xdm9z30yhkni70yhq9rz0zloo3j0zluadb35228d45bd12aa219bhhed7721570257ef77gfa7dfccghdb95df758f47ff95hfb749dd115a52dd21214f413541571526hhed887aehb7hhda55hhdbff25dfbbffdc25fb4557518722576e117b4bhh7chhffddhfdbfe7ab82924bb55dc245b116b5511fg218dachhb1cbghfda717cf77fhgg97fabdhe55ac5214fa25fg75bf24ef",
    cyanConcrete: "0g0g305objsv05obklb05oh6v31112010122111202100121222111122012212211101111202102221210222122211111211221111011021102021212212220211021022022201210110010212210211110202101010201110112020221222112102111202212110222110211221001010211001221212202222122111221102211100222112011211120220211",
    cyanWool: "0g0ge05obklb05oh6v305omt4v05omtxb05osg7305oy2gv05p3pj305p9bsv05p9clb05peyv305pkl4v05pklxb05pq87305pq8zj242269347912662167dda95521450145ab55cb659b88cd97649b546b35bb64db7536991146419921113b312431451424dda96656ad75dd9644dd97bb249b77bb9814b73445416521454a115737dd58ddbb99db97ba56762623774498234711474411bc116968dd7187cdb965158b55bdcc65b679da44684213b624bc547b23ab",
    grayConcrete: "0g0g20ehlvr30flk9a70000000000000000000000000000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000100000000000000000001000000010000",
    grayWool: "0g0gd0ehlvr30flk9a70flpvjz0flpwcf0flvim70gptwxr0gpzjzz0htxxj30hu3jsv0hu3klb0iy1y4f0iy7ke70iy7l6n333359337803663157cca85531350135ab55cb658b88cc87539b545b35bb53ca7535990036329930103b303330350335cc995556ac75cc8633cc87ba339b77ba8813a73435305532355a005737cc58ccab88cb87ba56753533773498333700574300ac205968cc7087cca865058b55bccc55b679ca33684313a634bc537a33ab",
    greenConcrete: "0g0g20k2mku70k2s73z0001000100111100101010100101101101101100111010010111001001011000100001100011000100101010110101111010000001011001001000100001010110101110010011010000101011110000010110101000000001010000110101011101000111110011101010011000111100001100011000000111101001101100",
    greenWool: "0g0gh0k2mku70k2s6bj0k2s73z0l6qjun0l6w64f0l71rlr0mb054v0mb5qm70mb5ren0nf9qf30nffcov0ojdq7z0ojjbpb0ojoxz30pnnbi70pnsxrz0rw0y6746447c45ab1499419aggcb8841580168ce88ee98bebbfgba96ce867e48ee96gda849cc125953cc41114e424642681546ggcc7789cga8ggb966ggbaed45ceaaedbb15da4658517843586c21894agg8bggdebbgebaec89a749449966cb445a116a6621de327c9bgga1bafgdb9828be88egee98e9acgc559b6414d946ef86ad44ce",
    lightBlueConcrete: "0g0g3090ti4f090z4e70a4xipr2120111111121222222121122112211121121211112221221111102221122212112021111111122111112111112121211222221111122121212121112021122112211121211211111121220111212121111121222001122211222221022122111011221111111021211221211211121112212111111122121111211112222111",
    lightBlueWool: "0g0gq090z4e70a4xipr0a534zj0a58r9b0b974sf0b9crun0b9ie4f0cdgrnj0cdmepr0cds0zj0dhqein0dhw0sf0dhw1kv0em01dr0em5nnj0fq9o8v0fqfain0gudou70gujb3z0hyhon30hynawv0hynbpb0j2lp8f0j2rbi70k6pptr0latpmn7b57fm89ik26ff63fippnkdd739d04benodepogdkojjppkifblodcfo8doofbpoie8fml21af95mm62428o817b81bd397cppmlffefnpidppkgbbppkioo79loiiookj4aoi8cad93fd55adcn22dh8ippejppookkpokiondfif6f68hhbcmj78ai22cicb22op51fmfjppi3jippokfd2ejoeeoppofdofilpn9agjc738og7copebio78no",
    lightGrayConcrete: "0g0g20yjgg730yjggzj1000110001001010100010000000011101100010001001011010001100101010001000000000000010100000000100010100000000001010100010001000000000100000110000100001100000011101110001001011001001001001011000000000011001001001001010000000010000000010100110000000001000001001",
    lightGrayWool: "0g0gi0yjgg730yjggzj0znkgsf0znkhkv10rohdr10roi6711vshz311vsirj11vy5tr12zwjcv12zwk5b1440jy7144670f1584kjj1584lbz16c8l4v16c8lxb17gclq745339e55bd1399329bhhfd7732570257ff78hfa7dfcchhdb95df769f57ff95hfb759ed115953ee31215f514551572537hhed9979fhb7hhda55hhdbff35dfbbgfdc25fb5657529733577f117b5bhh8chhfgddhfdbgf79b93935bb56ec355b117b6511fh319e9chhb2cbhhfd9718cf78fhhg97f9bdhf55ac6325fa36fh75bf35ff",
    limeConcrete: "0g0g30ppd5a70ppirjz0qth5331121111111100111111111110111110111010211100110111211111211101111112111111111111101110111011110211011011110111110102111110100111000110112112110211112112112111212111111111111111011111011100101111111111212111111111112010011011221111111110111120011110111101111",
    limeWool: "0g0gg0ppirjz0qth5330qtmrcv0rxl4vz0rxqr5r0t1p4ov0t1uqyn0u5t4hr0u5yqrj0v9x4an0va2qkf0we143j0xi53wf0ym3hfj0ym94hr10uh5of35237c44bb1299228affcb6632460257cd67ed96bdbbefba85bd657d46dd85fca748cb104942cc21214d403540562435ffcb7779cfb6ffb955ffbbdc34bdbaecbb24cb4546427622465c01694aff7bffcebbfdbbec69a728249955cb344a105a5501ce207c9bffa2bbefcb9607bd77dfee86d9abfc449b5324c935de75bc34cd",
    magentaConcrete: "0g0g419jw2rj1anugan1ao02kf1ao03cv2233313332221332333333233213322333223332331233333313323103121223222131233211303233130230322231223302323103002220333103232232223333313231221331233333231232212303302330122232333333332123320111033031332321233232303322232223332223231233212323332233222231230323",
    magentaWool: "0g0gs1ao02kf1ao03cv1brygvz1bs435r1bs43y71cw2hhb1cw83r31cw84jj1e06i2n1e0c4cf1e0c54v1f4ainz1f4g4xr1f4g5q71g8ej9b1g8k5j31g8k6bj1hcijun1hco64f1hco6wv1igmkfz1igs6pr1igs7i71jkw7b31jkw83j1kp08ov1lt49a71mxdwxr6945dl77ij14ff43ehrrmjba537a039cmoacqogajojjqrjhe9koa9do7booe9rnhc7elk118f74ll41317o7169719a275arrmkddcfmribrrjg99rrjion57koihonjj38ni798a72db448bam11bh7hrrcjrrnojjrojiomafhd4e47hh99lj578h11ah9911nq41dlfjrrh2jiqrnjfa1cjoccorqpebofhkrm78gj9537ng59oqc9in57mo",
    orangeConcrete: "0g0g21p59iwv1q97wfz1011110111101111111011111110000111101110100111111110011111011001001101110110111111111110111111011111101110111111110111111111111111011110111101111011101101101111010010111111110110101110010011101111111010101001101111111011111110111111111001111111101111111111",
    orangeWool: "0g0gm1q97wfz1rdbw8v1rdbx1b1rdhjb31shfwu71shfxmn1tljxfj1tljy7z1tlpkhr1upnytb1uptl331uptlvj1vtrzen1vtxlof1vtxmgv1wy1m9r1wy1n271wy79bz1wycwe71wyijgf1wyo5q71wytssf46239f55de02aa219dllhe8731570268hi79kib7eieelled96fi779i58ii96lhd859ff005a52ff20205i504650671537llgf998ahld8lleb66lledih35fiddihee25hd5757519822587h008c5dll9ellhieeliedih7ad92925cc67fe355d007d7600hk209faelld1edllhea709ei89ilkj98iadflh55be7315hb37il86dh35hi",
    pinkConcrete: "0g0g31ltks8v1mxj5rz1mxj6kf1122212121112211111211211211122112111221111111121211212111122211111112112121112111111111111112111212221121111111212211112101110212211211122111211112212111211110211211211211111111121212221211121111112212211121211111211212211111111111121112111211212122122111",
    pinkWool: "0g0gv1mxj6kf1o1hk3j1o1n6db1p5r6yn1q9v6rj1q9v7jz1rdz7cv1re4uf31si37y71si8u7z1tm78jj1tmcutb1tmcvlr1uqgven1uqmigv1uqs4qn1vuqj271vuw5bz1vuw64f1vv1se71vv7fgf1vvd1q71vvd2in1vviosf1vvipkv1vvobun1vvocn31vvtywv1vvzlz31vw588v1vw591b6a46em78jk25gg53fjuuokdc638c03adoqcesqhckqkktukjfalqcbeq7dqqfaupjd7fml219g83mm52327q716a71ac386buunleedgoujduukhaauukjqp68lqjjrpkk39pj7b9c83ed439dbo12di7juuekuuprkkuqkjrocgje5f57iiabmk679j22bjba12ps31emgkuuj3kjtupkgc1ekqdequssfdqgjluo89hkb637ph6bqtdajp67oq",
    purpleConcrete: "0g0g40qo16v30rrzke70rrzl6n0rs57gf3222322033323333333312320220233231302222232332333202332233033330333322320012333323333330233022223332223332223232323303323233332332021220323110033223333322032332312323332322322202232223033232221223233023333332022233332332233232023333233223032323332323323332",
    purpleWool: "0g0gm0rrzl6n0rs57gf0sw3kzj0sw3lrz0u01zb30u07lkv0u07mdb0v45zwf0w84dfj0w84e7z0xc8e0v0xc8etb0yg6scf0ygcem70zkasxr10o96gv10o979b10oetj311sd72711sd7un12wh8fz154uxhb47349e45ce13aa32acllfe8742570279fh79jhb7ehddkleca7eh779h48hha7lgc94aee116a52ee31214h414741771547llfe999aflc8lleb77llechg45ehcchged26gc4767519832687f118c4cll9dllgheelhechf7ac93a34cc77ed446c117c7711gj219eadllc1dcklgea719dh99hljia8hacelf56bd7424gb47hk97cg44fh",
    redConcrete: "0g0g112voa9r0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    redWool: "0g0gd12voa9r13zmnsv153l1bz167jev3167p14v17bnenz18fls7319jprzz1ano5j31ano6bj1brmjun1brs64f1f3yku7241258227712662157cc9754212401459b45bb647b77bc77548b445b25bb54ca7525881036218821112b202420441224cc8855569c75cc7644cc77ba228b77ba7713a724342155113549015627cc57ccab77cb77b946752522664487223711474401ab105867cc7177bca764057b55bcbb55b678c923674212a624bb547a229b",
    whiteConcrete: "0g0g31ktui9r1ku04jj1lxyi2n1121212211221121111221111121122111211111121112111212112211111211212222111111221112211112101110211111122211211211111111212221111112212121212222111121122211111111222111111112121222121111111111211121221112221111121222121112212122111221211212111121221211221212",
    whiteWool: "0g0gn1lxyi2n1lxyiv31ly454v1n22inz1n22jgf1n285q71o66j9b1o66k1r1o6c6bj1paajun1qeekfz1ricyrj1riil1b1smgykf1smmlmn1tqkz5r1tqqm7z1uuozr31uuumtb1vyt0cf1vyynen1x2x0xr1y711j37a56dj89hi26ee63egmmliba639a04acllacmlfailiimmigeajlaadl8blleamlgc8ejj219e94jj62429l817a81aa396ammkjddcelmhbmmifaammihll69jlhgllii49lh8a9a93db549bal12bg8gmmcimmlliimlihllaegd6e68ggaaji689g22agaa12lm41djeimmg3ihmmliea1cilcclmmmeblegjml99fia638lf6almcahl68ll",
    yellowConcrete: "0g0g41to1w5b1us09of1us5vy71us5wqn2111111122222221232021021213122222211020112110121211022201012212122222312211221122213110202011133121132211112221221211211111112120231210211111201132001211212111211102220222021102211223011100222121202222222132111211111112111112021121120222221222011012122121",
    yellowWool: "0g0gj1us5vy71usbj0f1vw9wjj1vwfitb1vwfjlr1vwl5vj1vwl6nz1vwqsxr1x0p6gv1x0utj31x10fsv1x10glb1x163nj1y54h6n1y5a48v1y5a51b1y5frb31y5fs3j1y5lf5r45239e44bc0299219biiec7731470158eg78hga7cgcchicb95dg759g47gg95ifb849ed005942ee20104g404540571436iied9989eib7iica55iicbgf34dgbbgfcc15fb4557419722576e007b4bii8ciifgccigcbge79b92924bb55ec345b006b5500fh209e9ciib1cbhifc9708cg88gihh97g9bdie45ac5314fa35gh85bf34eg",
};

var blockData = [
    {
        name: "air",
        id: 0,
        textures: [],
        transparent: true,
        shadow: false
    },
    {
        name: "grass",
        textures: ["dirt", "grassTop", "grassSide"]
    },
    { name: "dirt" },
    { name: "stone" },
    { name: "bedrock" },
    { name: "sand" },
    { name: "gravel" },
    {
        name: "leaves",
        transparent: true
    },
    {
        name: "glass",
        transparent: true,
        shadow: false
    },
    { name: "cobblestone" },
    { name: "mossyCobble" },
    { name: "stoneBricks" },
    { name: "mossyStoneBricks" },
    { name: "bricks" },
    { name: "coalOre" },
    { name: "ironOre" },
    { name: "goldOre" },
    { name: "diamondOre" },
    { name: "redstoneOre" },
    { name: "lapisOre" },
    { name: "emeraldOre" },
    { name: "coalBlock" },
    { name: "ironBlock" },
    { name: "goldBlock" },
    { name: "diamondBlock" },
    { name: "redstoneBlock" },
    { name: "lapisBlock" },
    { name: "emeraldBlock" },
    // { // I swear, if y'all don't stop asking about TNT every 5 minutes!
    //     name: "tnt",
    //     textures: ["tntBottom", "tntTop", "tntSides"]
    // },
    { name: "oakPlanks" },
    {
        name: "oakLog",
        textures: ["logTop", "logSide"],
    },
    { name: "acaciaPlanks" },
    {
        name: "acaciaLog",
        textures: ["acaciaLogTop", "acaciaLogSide"]
    },
    { name: "birchPlanks" },
    {
        name: "birchLog",
        textures: ["birchLogTop", "birchLogSide"]
    },
    { name: "darkOakPlanks" },
    {
        name: "darkOakLog",
        textures: ["darkOakLogTop", "darkOakLogSide"]
    },
    { name: "junglePlanks" },
    {
        name: "jungleLog",
        textures: ["jungleLogTop", "jungleLogSide"]
    },
    { name: "sprucePlanks" },
    {
        name: "spruceLog",
        textures: ["spruceLogTop", "spruceLogSide"]
    },
    { name: "whiteWool" },
    { name: "orangeWool" },
    { name: "magentaWool" },
    { name: "lightBlueWool" },
    { name: "yellowWool" },
    { name: "limeWool" },
    { name: "pinkWool" },
    { name: "grayWool" },
    { name: "lightGrayWool" },
    { name: "cyanWool" },
    { name: "purpleWool" },
    { name: "blueWool" },
    { name: "brownWool" },
    { name: "greenWool" },
    { name: "redWool" },
    { name: "blackWool" },
    { name: "whiteConcrete" },
    { name: "orangeConcrete" },
    { name: "magentaConcrete" },
    { name: "lightBlueConcrete" },
    { name: "yellowConcrete" },
    { name: "limeConcrete" },
    { name: "pinkConcrete" },
    { name: "grayConcrete" },
    { name: "lightGrayConcrete" },
    { name: "cyanConcrete" },
    { name: "purpleConcrete" },
    { name: "blueConcrete" },
    { name: "brownConcrete" },
    { name: "greenConcrete" },
    { name: "redConcrete" },
    { name: "blackConcrete" },
];

(function() {
    for (var i = 1; i < blockData.length; i++) {
        var data = blockData[i];
        data.id = i;

        if (!data.textures) {
            data.textures = [data.name, data.name, data.name, data.name, data.name, data.name];
        } else if (typeof data.textures === "string") {
            var texture = data.textures;
            data.textures = [texture, texture, texture, texture, texture, texture];
        } else if (data.textures.length === 3) {
            data.textures[3] = data.textures[2];
            data.textures[4] = data.textures[2];
            data.textures[5] = data.textures[2];
        } else if (data.textures.length === 2) {
            // Top and bottom are the first texture, sides are the second.
            data.textures[2] = data.textures[1];
            data.textures[3] = data.textures[2];
            data.textures[4] = data.textures[2];
            data.textures[5] = data.textures[2];
            data.textures[1] = data.textures[0];
        }

        data.transparent = data.transparent || false;
        data.shadow = data.shadow !== undefined ? data.shadow : true;
    }
})();

var win = window.parent;
var doc = document;
var console = win.console;
var world;

var newFloat32Array = function(arr) {
    return new Float32Array(arr);
};
var newInt32Array = function(arr) {
    return new Int32Array(arr);
};
var newUint32Array = function(arr) {
    return new Uint32Array(arr);
};
var newUint16Array = function(arr) {
    return new Uint16Array(arr);
};
var newUint8Array = function(arr) {
    return new Uint8Array(arr);
};

var seedHash;
var hash = (function() {
    var seed = (Math.random() * 2100000000) | 0;
	var PRIME32_2 = 1883677709;
	var PRIME32_3 = 2034071983;
	var PRIME32_4 = 668265263;
	var PRIME32_5 = 374761393;
	
	seedHash = function(s) {
	    seed = s | 0;
	};
	
	return function(x, y) {
	    var h32 = 0;
		
		h32 = (seed + PRIME32_5) | 0;
		h32 += 8;
		
		h32 += Math.imul(x, PRIME32_3);
		h32 = Math.imul((h32 << 17) | (h32 >> (32 - 17)), PRIME32_4);
		h32 += Math.imul(y, PRIME32_3);
		h32 = Math.imul((h32 << 17) | (h32 >> (32 - 17)), PRIME32_4);
		
		h32 ^= h32 >> 15;
		h32 *= PRIME32_2;
		h32 ^= h32 >> 13;
		h32 *= PRIME32_3;
		h32 ^= h32 >> 16;
		
		return h32 / 2147483647;
	};
})();
var worldSeed;

//The noise and random functions are copied from the processing.js source code; these others are polyfills made by me to avoid needing to remove all the pjs draw calls
var currentRandom = null;
function Marsaglia(i1, i2) {
	// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c
	var z=i1 || 362436069, w= i2 || 521288629;
	var nextInt = function() {
		z=(36969*(z&65535)+(z>>>16)) & 0xFFFFFFFF;
		w=(18000*(w&65535)+(w>>>16)) & 0xFFFFFFFF;
		return (((z&0xFFFF)<<16) | (w&0xFFFF)) & 0xFFFFFFFF;
	};

	this.nextDouble = function() {
		var i = nextInt() / 4294967296;
		return i < 0 ? 1 + i : i;
	};
	this.nextInt = nextInt;
}
var randomSeed = function(seed) {
	currentRandom = (new Marsaglia(seed)).nextDouble;
}
var random = function(min, max) {
    if (!max) {
        if (min) {
            max = min;
            min = 0;
        } else {
            min = 0;
            max = 1;
        }
    }
    return currentRandom() * (max - min) + min;
}
var noiseProfile = { generator: undefined, octaves: 4, fallout: 0.5, seed: undefined};
function PerlinNoise(seed) {
	var rnd = seed !== undefined ? new Marsaglia(seed) : Marsaglia.createRandomized();
	var i, j;
	// http://www.noisemachine.com/talk1/17b.html
	// http://mrl.nyu.edu/~perlin/noise/
	// generate permutation
	var perm = new Uint8Array(512);
	for(i=0;i<256;++i) { perm[i] = i; }
	for(i=0;i<256;++i) { var t = perm[j = rnd.nextInt() & 0xFF]; perm[j] = perm[i]; perm[i] = t; }
	// copy to avoid taking mod in perm[0];
	for(i=0;i<256;++i) { perm[i + 256] = perm[i]; }

	function grad3d(i,x,y,z) {
		var h = i & 15; // convert into 12 gradient directions
		var u = h<8 ? x : y,
		v = h<4 ? y : h===12||h===14 ? x : z;
		return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);
	}

	function grad2d(i,x,y) {
		var v = (i & 1) === 0 ? x : y;
		return (i&2) === 0 ? -v : v;
	}

	function grad1d(i,x) {
		return (i&1) === 0 ? -x : x;
	}

	function lerp(t,a,b) { return a + t * (b - a); }

	this.noise3d = function(x, y, z) {
		var X = Math.floor(x)&255, Y = Math.floor(y)&255, Z = Math.floor(z)&255;
		x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
		var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y, fz = (3-2*z)*z*z;
		var p0 = perm[X]+Y, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z,
		p1 = perm[X + 1] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;
		return lerp(fz,
		lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x-1, y, z)),
		lerp(fx, grad3d(perm[p01], x, y-1, z), grad3d(perm[p11], x-1, y-1,z))),
		lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z-1), grad3d(perm[p10 + 1], x-1, y, z-1)),
		lerp(fx, grad3d(perm[p01 + 1], x, y-1, z-1), grad3d(perm[p11 + 1], x-1, y-1,z-1))));
	};

	this.noise2d = function(x, y) {
		var X = Math.floor(x)&255, Y = Math.floor(y)&255;
		x -= Math.floor(x); y -= Math.floor(y);
		var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y;
		var p0 = perm[X]+Y, p1 = perm[X + 1] + Y;
		return lerp(fy,
		lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x-1, y)),
		lerp(fx, grad2d(perm[p0 + 1], x, y-1), grad2d(perm[p1 + 1], x-1, y-1)));
	};

	this.noise1d = function(x) {
		var X = Math.floor(x)&255;
		x -= Math.floor(x);
		var fx = (3-2*x)*x*x;
		return lerp(fx, grad1d(perm[X], x), grad1d(perm[X+1], x-1));
	};
}
var noiseSeed = function(seed) {
    noiseProfile.seed = seed;
    noiseProfile.generator = undefined;
};
var noise = function(x, y, z) {
	if(noiseProfile.generator === undefined) {
		// caching
		noiseProfile.generator = new PerlinNoise(noiseProfile.seed);
	}
	var generator = noiseProfile.generator;
	var effect = 1, k = 1, sum = 0;
	for(var i=0; i<noiseProfile.octaves; ++i) {
		effect *= noiseProfile.fallout;
		switch (arguments.length) {
			case 1:
			sum += effect * (1 + generator.noise1d(k*x))/2; break;
			case 2:
			sum += effect * (1 + generator.noise2d(k*x, k*y))/2; break;
			case 3:
			sum += effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; break;
		}
		k *= 2;
	}
	return sum;
};
var PVector = function(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.set = function(x, y, z) {
		if (y === undefined) {
			this.x = x.x;
			this.y = x.y;
			this.z = x.z;
		} else {
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}
    this.normalize = function() {
        var mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        this.x /= mag;
        this.y /= mag;
        this.z /= mag;
    }
    this.add = function(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
    }
    this.mult = function(m) {
        this.x *= m;
        this.y *= m;
        this.z *= m;
    }
}
var rect = function(x, y, w, h) {
    ctx.fillRect(x, y, w, h);
}
var fill = function(r, g, b) {
	if (g === undefined) {
		g = r;
		b = r;
	}
    ctx.fillStyle = "rgb(" + r + ", " + g + ", " + b + ")"
}
var stroke = function(r, g, b) {
	if (g === undefined) {
		g = r;
		b = r;
	}
	ctx.strokeStyle = "rgb(" + r + ", " + g + ", " + b + ")"
}
var line = function(x1, y1, x2, y2) {
	ctx.moveTo(x1, y1);
	ctx.lineTo(x2, y2);
}
function fastText(txt, x, y, h) {
	h = h || 0;
	
    var lines = txt.split("\n");
    for (var i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i], x, y + h * i);
    }
}
function textSize(size) {
	ctx.font = size + 'px Sans-Serif';
}
var text = fastText;
var strokeWeight = function(num) {
    ctx.lineWidth = num;
}
var HAND = "pointer";
var CROSS = "crosshair";
var LEFT = 37, UP = 38, RIGHT = 39, DOWN = 40;
var cursor = function(type) {
    canvas.style.cursor = type;
}
randomSeed(Math.random() * 10000000 | 0);

{
var fov = 70; // Field of view in degrees
var version = "Alpha 0.3";
var reach = 5; // Max distance player can place or break blocks

var blockIds = {};
blockData.forEach(function(block) { blockIds[block.name] = block.id; });

var currentFov, targetFov, fovTime;
var renderDistance;
var generatedChunks;
var mouseX, mouseY;
var width = window.innerWidth;
var height = window.innerHeight;
var generator = {
    height: 80,
    smooth: 0.01,
};
var maxHeight = 255;
var blockOutlines = false;
var blockFill = true;
var updateHUD = true;
var textureMap;
var textureCoords;
var texCoordsBuffers;
var bigArray = bigArray || newFloat32Array(200000);

var screen;
angleMode = "radians";
var hitBox = {};
var holding = 0;
var Key = {};
var g;
var modelView = modelView || newFloat32Array(16);
var glCache;
var nearH;
var freezeFrame = 0;
var p;
var vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector(), vec4 = new PVector();
var move = {
    x: 0,
    y: 0,
    z: 0,
    ang: Math.sqrt(0.5),
};
var p2 = {
    x: 0,
    y: 0,
    z: 0,
};
var place, pauseIMG;
var inventory = {
    hotbar: [1, 2, 3, 4, 5, 6, 7, 8, 9],
    main: [],
    hotbarSlot: 0,
    size: 40,
    holding: 0
};

} //Globals

function play() {
	screen = "play";
	getPointer();
	fill(255, 255, 255);
	textSize(10);
	p.lastBreak = Date.now();
    updateHUD = true;
	gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
}

var gl;
function getPointer() {
    if (canvas.requestPointerLock) {
        canvas.requestPointerLock();
    }
}
function releasePointer() {
    if (doc.exitPointerLock) {
        doc.exitPointerLock();
    }
}


var Block = {
    top: 0x4,
    bottom: 0x8,
    north: 0x20,
    south: 0x10,
    east: 0x2,
    west: 0x1,
};
var Sides = {
    top: 0,
    bottom: 1,
    north: 2,
    south: 3,
    east: 4,
    west: 5
};

//GLSL Shader code
{
var vertexShaderSrc3D = "" +
    "varying float vShadow;" +
    "attribute vec3 aVertex;" +
    "attribute vec2 aTexture;" +
    "attribute float aShadow;" +
    "varying   vec2 vTexture;" +
    "uniform vec4 uColor;" +
    "uniform mat4 uView;" +
    "uniform mat4 uProjection;" +
    "uniform bool uEdge;" +
    
    "void main(void) {" +
    "  vTexture = aTexture;" +
    "  vShadow = aShadow > 0.0 ? aShadow : 1.0;" +
    "  gl_Position = uView * vec4( aVertex, 1.0 );" +
    
    //"  vShadow = 1.0;"+// - gl_Position.z / 10000.0;" +
    "}";

var fragmentShaderSrc3D = "" +
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n" +
    "  precision highp float;\n" +
    "#else\n" +
    "  precision mediump float;\n" +
    "#endif\n" +

    "varying float vShadow;" +

    "uniform sampler2D uSampler;" +
    "varying vec2 vTexture;" +

    "void main(void){" +
    "  vec4 color = texture2D(uSampler, vTexture);" +
    "  gl_FragColor = vec4(color.rgb * vShadow, color.a);" +
    "  if (gl_FragColor.a == 0.0) discard;" +
    "}";
}

var createProgramObject = function(curContext, vetexShaderSource, fragmentShaderSource) {
    var vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER);
    curContext.shaderSource(vertexShaderObject, vetexShaderSource);
    curContext.compileShader(vertexShaderObject);
    if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
        throw curContext.getShaderInfoLog(vertexShaderObject);
    }
    
    var fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER);
    curContext.shaderSource(fragmentShaderObject, fragmentShaderSource);
    curContext.compileShader(fragmentShaderObject);
    if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
        throw curContext.getShaderInfoLog(fragmentShaderObject);
    }
    
    var programObject = curContext.createProgram();
    curContext.attachShader(programObject, vertexShaderObject);
    curContext.attachShader(programObject, fragmentShaderObject);
    curContext.linkProgram(programObject);
    if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
        throw "Error linking shaders.";
    }
    
    return programObject;
};

var programObject3D;
/*
var boxVerts = newFloat32Array([
    0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,//South
    0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,//North
    0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,//East
    0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,//Bottom
   -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5,//West
    0.5,  0.5,  0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5 //Top
]);
 var sideFaceVerts = { //Must use GL_TRIANGLES for these
    south:  newFloat32Array([0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5]),
    north:  newFloat32Array([0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5]),
    east:   newFloat32Array([0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5]),
    top: newFloat32Array([0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5]),
    west:  newFloat32Array([-0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5]),
    bottom:    newFloat32Array([0.5,  0.5,  0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5])
};*/
var sideEdgeVerts = [
    newFloat32Array([-0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5]), //top
    newFloat32Array([-0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5]), //bottom
    newFloat32Array([ 0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5]), //north
    newFloat32Array([-0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5]), //south
    newFloat32Array([ 0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5]), //east
    newFloat32Array([-0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5])  //west
];
var indexOrder;
(function() {
    var arr = [];
    for (var i = 0; i < 20000; i++) {
        arr.push(0 + i * 4, 1 + i * 4, 2 + i * 4, 0 + i * 4, 2 + i * 4, 3 + i * 4);
    }
    indexOrder = newUint32Array(arr);
})();
var boxOutlineVerts = newFloat32Array([
    0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5,
   -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,
    0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5,
   -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,
    0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5,
   -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5
]);
var boxVerts = [
    [0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5], //top
    [0.5,  0.5,  0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5], //bottom
    [0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5], //north
    [0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5], //south
    [0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5], //east
   [-0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5], //west
];
var hexagonVerts;
var blockIcons;
(function() {
    var side = Math.sqrt(3) / 2;
    hexagonVerts = newFloat32Array([
        0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
        0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
        -side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1
    ]);
})();
function genIcons() {
    blockIcons = [null];
    var texOrder = [1, 2, 2];
    var shadows = [1, 0.4, 0.7];
    var scale = 0.16 / height * inventory.size;
    for (var i = 1; i < blockData.length; i++) {
        var data = [];
        var block = blockData[i];
        console.log(block.name)
        for (var j = 0; j < 12; j++) {
            data.push(hexagonVerts[j * 3 + 0] * scale);
            data.push(hexagonVerts[j * 3 + 1] * scale);
            data.push(0.1666666);
            data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 0) % 8]);
            data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 1) % 8]);
            data.push(shadows[Math.floor(j / 4)]);
        }
        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, newFloat32Array(data), gl.STATIC_DRAW);
        blockIcons.push(buffer);
    }
}

function uniformf(cacheId, programObj, vrName, vrValue) {
    var vrLocation = glCache.locations[cacheId];
    if(vrLocation === undefined) {
        vrLocation = gl.getUniformLocation(programObj, vrName);
        glCache.locations[cacheId] = vrLocation;
    }
    // the variable won't be found if it was optimized out.
    if (vrLocation !== null) {
        if (vrValue.length === 4) {
          gl.uniform4fv(vrLocation, vrValue);
        } else if (vrValue.length === 3) {
          gl.uniform3fv(vrLocation, vrValue);
        } else if (vrValue.length === 2) {
          gl.uniform2fv(vrLocation, vrValue);
        } else {
          gl.uniform1f(vrLocation, vrValue);
        }
    }
}
function uniformi(cacheId, programObj, vrName, vrValue) {
    var vrLocation = glCache.locations[cacheId];
    if(vrLocation === undefined) {
        vrLocation = gl.getUniformLocation(programObj, vrName);
        glCache.locations[cacheId] = vrLocation;
    }
    // the variable won't be found if it was optimized out.
    if (vrLocation !== null) {
        if (vrValue.length === 4) {
            gl.uniform4iv(vrLocation, vrValue);
        } else if (vrValue.length === 3) {
            gl.uniform3iv(vrLocation, vrValue);
        } else if (vrValue.length === 2) {
            gl.uniform2iv(vrLocation, vrValue);
        } else {
            gl.uniform1i(vrLocation, vrValue);
        }
    }
}
function uniformMatrix(cacheId, programObj, vrName, transpose, matrix) {
    var vrLocation = glCache.locations[cacheId];
    if(vrLocation === undefined) {
        vrLocation = gl.getUniformLocation(programObj, vrName);
        glCache.locations[cacheId] = vrLocation;
    }
    gl.uniformMatrix4fv(vrLocation, transpose, matrix);
}
function vertexAttribPointer(cacheId, programObj, vrName, size, VBO) {
    var vrLocation = glCache.locations[cacheId];
    if(vrLocation === undefined) {
        vrLocation = gl.getAttribLocation(programObj, vrName);
        glCache.locations[cacheId] = vrLocation;
    }
    if (vrLocation !== -1) {
        gl.enableVertexAttribArray(vrLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
        gl.vertexAttribPointer(vrLocation, size, gl.FLOAT, false, 0, 0);
        
    }
}
function disableVertexAttribArray(cacheId, programObj, vrName){
    var vrLocation = glCache.attributes[cacheId];
    if(vrLocation === undefined) {
        vrLocation = gl.getAttribLocation(programObj, vrName);
        glCache.attributes[cacheId] = vrLocation;
    }
    if (vrLocation !== -1) {
        gl.disableVertexAttribArray(vrLocation);
    }
}

//Generate buffers for every block face and store them
var sideEdgeBuffers;
var indexBuffer;

/** Matrix and Vector transformation methods **/
//{
var matrix = matrix || newFloat32Array(16);
var projection = projection || newFloat32Array(16);
function trans(matrix, x, y, z) {
    var a = matrix;
    a[3] += a[0] * x + a[1] * y + a[2] * z;
    a[7] += a[4] * x + a[5] * y + a[6] * z;
    a[11] += a[8] * x + a[9] * y + a[10] * z;
    a[15] += a[12] * x + a[13] * y + a[14] * z;
}
function rotX(matrix, angle) {
    // source = [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]
    var elems = matrix;
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = elems[1];
    elems[1] = t * c + elems[2] * s;
    elems[2] = t * -s + elems[2] * c;
    t = elems[5];
    elems[5] = t * c + elems[6] * s;
    elems[6] = t * -s + elems[6] * c;
    t = elems[9];
    elems[9] = t * c + elems[10] * s;
    elems[10] = t * -s + elems[10] * c;
    t = elems[13];
    elems[13] = t * c + elems[14] * s;
    elems[14] = t * -s + elems[14] * c;
}
function rotY(matrix, angle) {
    //source = c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var elems = matrix;
    var t = elems[0];
    elems[0] = t * c + elems[2] * -s;
    elems[2] = t * s + elems[2] * c;
    t = elems[4];
    elems[4] = t * c + elems[6] * -s;
    elems[6] = t * s + elems[6] * c;
    t = elems[8];
    elems[8] = t * c + elems[10] * -s;
    elems[10] = t * s + elems[10] * c;
    t = elems[12];
    elems[12] = t * c + elems[14] * -s;
    elems[14] = t * s + elems[14] * c;
}
function transpose(matrix) {
    var temp = matrix[4];
    matrix[4] = matrix[1];
    matrix[1] = temp;

    temp = matrix[8];
    matrix[8] = matrix[2];
    matrix[2] = temp;

    temp = matrix[6];
    matrix[6] = matrix[9];
    matrix[9] = temp;

    temp = matrix[3];
    matrix[3] = matrix[12];
    matrix[12] = temp;

    temp = matrix[7];
    matrix[7] = matrix[13];
    matrix[13] = temp;

    temp = matrix[11];
    matrix[11] = matrix[14];
    matrix[14] = temp;
}
function matMult() {
    //Multiply the projection matrix by the view matrix; this is optimized specifically for these matrices by removing terms that are always 0.
    var proj = projection;
    var view = modelView;
    matrix[0] = proj[0] * view[0];
    matrix[1] = proj[0] * view[1];
    matrix[2] = proj[0] * view[2];
    matrix[3] = proj[0] * view[3];
    matrix[4] = proj[5] * view[4];
    matrix[5] = proj[5] * view[5];
    matrix[6] = proj[5] * view[6];
    matrix[7] = proj[5] * view[7];
    matrix[8] = proj[10] * view[8] + proj[11] * view[12];
    matrix[9] = proj[10] * view[9] + proj[11] * view[13];
    matrix[10] = proj[10] * view[10] + proj[11] * view[14];
    matrix[11] = proj[10] * view[11] + proj[11] * view[15];
    matrix[12] = proj[14] * view[8];
    matrix[13] = proj[14] * view[9];
    matrix[14] = proj[14] * view[10];
    matrix[15] = proj[14] * view[11];
}
function copyArr(a, b) {
    for (var i = 0; i < a.length; i++) {
        b[i] = a[i];
    }
}
function FOV(fov) {
    var tang = Math.tan(fov * 0.5 * Math.PI / 180);
    var scale = 1 / tang;
    var near = 1;
    var far = 1000000;
    currentFov = fov;
    nearH = near * tang;
    
    projection[0] = scale / width * height;
    projection[5] = scale;
    projection[10] = -far / (far - near);
    projection[11] = -1;
    projection[14] = -far * near / (far - near);
    
    // Set the projecction matrix in the shader
    // copyArr(projection, matrix);
    // transpose(matrix);
    // uniformMatrix("projection3d", programObject3D, "uProjection", false, matrix);
}
function cross(v1, v2, result) {
    var x = v1.x,
        y = v1.y,
        z = v1.z,
        x2 = v2.x,
        y2 = v2.y,
        z2 = v2.z;
    result.x = y * z2 - y2 * z;
    result.y = z * x2 - z2 * x;
    result.z = x * y2 - x2 * y;
}
//}

function Plane(nx, ny, nz) {
    this.dx = nx > 0 ? 16 : 0;
    this.dy = ny > 0;
    this.dz = nz > 0 ? 16 : 0;
    
    // Normal vector
    this.nx = nx;
    this.ny = ny;
    this.nz = nz;
}
Plane.prototype.set = Plane;
function computeFrustum() {
    var X = vec1;
    X.x = p.direction.z;
	X.y = 0
	X.z = -p.direction.x;
    X.normalize();
    
    var Y = vec2;
    Y.set(p.direction);
    Y.mult(-1);
    cross(Y, X, Y);
    
    //Near plane (hoisted to outside the render loop to improve performance)
    // var x = p.x + p.direction.x;
    // var y = p.y + p.direction.y;
    // var z = p.z + p.direction.z;
    // p.frustum[0].set(x, y, z, p.direction.x, p.direction.y, p.direction.z);
    
    var aux = vec3;
    aux.set(Y);
    aux.mult(nearH);
    aux.add(p.direction);
    aux.normalize();
    cross(aux, X, aux);
    p.frustum[0].set(aux.x, aux.y, aux.z);
    
    aux.set(Y);
    aux.mult(-nearH);
    aux.add(p.direction);
    aux.normalize();
    cross(X, aux, aux);
    p.frustum[1].set(aux.x, aux.y, aux.z);
    
    aux.set(X);
    aux.mult(-nearH * width / height);
    aux.add(p.direction);
    aux.normalize();
    cross(aux, Y, aux);
    p.frustum[2].set(aux.x, aux.y, aux.z);
    
    aux.set(X);
    aux.mult(nearH * width / height);
    aux.add(p.direction);
    aux.normalize();
    cross(Y, aux, aux);
    p.frustum[3].set(aux.x, aux.y, aux.z);
}
var chunkVisible = function(x, y, z, maxY) {
    x -= 0.5;
    y -= 0.5;
    z -= 0.5;
    maxY += 0.5;
    var maxX = x + 16;
    var maxZ = z + 16;
    var px = 0, py = 0, pz = 0, plane = null;
    var cx = p.x, cy = p.y, cz = p.z;
    for (var i = 0; i < 4; i++) {
        plane = p.frustum[i];
        px = x + plane.dx;
        py = plane.dy ? maxY : y;
        pz = z + plane.dz;
        if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
            return false;
        }
    }
    return true;
};

var defaultModelView = newFloat32Array([-4,0,0,0,0,4,0,0,0,0,-4,0,0,0,0,1]);
var initModelView = function(x, y, z, rx, ry) {
    copyArr(defaultModelView, modelView);
    rotX(modelView, rx);
    rotY(modelView, ry);
    trans(modelView, -x, -y, -z);
    matMult();
    transpose(matrix);
    uniformMatrix("view3d", programObject3D, "uView", false, matrix);
};
var tex;

function getFaces(x, y, z) {
    return (p.x < x - 0.5) |
    (p.x > x + 0.5) << 1 |
    (p.y < y - 0.5) << 2 |
    (p.y > y + 0.5) << 3 |
    (p.z < z - 0.5) << 4 |
    (p.z > z + 0.5) << 5;
}
function rayTrace(x, y, z, sides) {
    x -= 0.5;
    y -= 0.5;
    z -= 0.5;
    
    var cf, cd = 1e9; //Closest face and distance
    var m; //Absolute distance to intersection point
    var ix, iy, iz; //Intersection coords
    
    //Top and bottom faces
    if (Block.top & sides && p.direction.y) {
        m = (y - p.y) / p.direction.y;
        ix = m * p.direction.x + p.x;
        iz = m * p.direction.z + p.z;
        if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iz >= z && iz <= z + 1) {
            cd = m; //Ray crosses top face
            cf = "top";
        }
    }
    y += 1;
    if (Block.bottom & sides && p.direction.y) {
        m = (y - p.y) / p.direction.y;
        ix = m * p.direction.x + p.x;
        iz = m * p.direction.z + p.z;
        if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iz >= z && iz <= z + 1) {
            cd = m;
            cf = "bottom";
        }
    }
    y -= 1;
    
    //West and East faces
    if (Block.west & sides && p.direction.x) {
        m = (x - p.x) / p.direction.x;
        iy = m * p.direction.y + p.y;
        iz = m * p.direction.z + p.z;
        if (m > 0 && m < cd && iy >= y && iy <= y + 1 && iz >= z && iz <= z + 1) {
            cd = m;
            cf = "west";
        }
    }
    x += 1;
    if (Block.east & sides && p.direction.x) {
        m = (x - p.x) / p.direction.x;
        iy = m * p.direction.y + p.y;
        iz = m * p.direction.z + p.z;
        if (m > 0 && m < cd && iy >= y && iy <= y + 1 && iz >= z && iz <= z + 1) {
            cd = m;
            cf = "east";
        }
    }
    x -= 1;
    
    //South and North faces
    if (Block.south & sides && p.direction.z) {
        m = (z - p.z) / p.direction.z;
        ix = m * p.direction.x + p.x;
        iy = m * p.direction.y + p.y;
        if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iy >= y && iy <= y + 1) {
            cd = m;
            cf = "south";
        }
    }
    z += 1;
    if (Block.north & sides && p.direction.z) {
        m = (z - p.z) / p.direction.z;
        ix = m * p.direction.x + p.x;
        iy = m * p.direction.y + p.y;
        if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iy >= y && iy <= y + 1) {
            cd = m;
            cf = "north";
        }
    }
    return [cd, cf];
}
function runRayTrace(x, y, z, faces) {
    var block = world.getBlock(x, y, z);
    if (block) {
        var rt = rayTrace(x, y, z, faces);
        
        if (rt[1] && rt[0] < hitBox.closest) {
            hitBox.closest = rt[0];
            hitBox.face = rt[1];
            hitBox.pos = [x, y, z];
        }
    }
}
function lookingAt() {
    // Checks blocks in front of the player to see which one they're looking at
    hitBox.pos = null;
    hitBox.closest = 1e9;
    var pd = p.direction;
    
    // Target block
    var tx = Math.round(pd.x * reach + p.x);
    var ty = Math.round(pd.y * reach + p.y);
    var tz = Math.round(pd.z * reach + p.z);
    
    var minX = p2.x;
    var maxX = 0;
    var minY = p2.y;
    var maxY = 0;
    var minZ = p2.z;
    var maxZ = 0;
    var faces = getFaces(tx, ty, tz);

    for (var i = 1; i < reach + 1; i++) {
        if (i > reach) {
            i = reach;
        }
        maxX = Math.round(p.x + pd.x * i);
        maxY = Math.round(p.y + pd.y * i);
        maxZ = Math.round(p.z + pd.z * i);
        if (maxX === minX && maxY === minY && maxZ === minZ) {
            continue;
        }
        if (minX !== maxX) {
            if (minY !== maxY) {
                if (minZ !== maxZ) {
                    runRayTrace(maxX, maxY, maxZ, faces);
                }
                runRayTrace(maxX, maxY, minZ, faces);
            }
            if (minZ !== maxZ) {
                runRayTrace(maxX, minY, maxZ, faces);
            }
            runRayTrace(maxX, minY, minZ, faces);
        }
        if (minY !== maxY) {
            if (minZ !== maxZ) {
                runRayTrace(minX, maxY, maxZ, faces);
            }
            runRayTrace(minX, maxY, minZ, faces);
        }
        if (minZ !== maxZ) {
            runRayTrace(minX, minY, maxZ, faces);
        }
        if (hitBox.pos) {
            return; //The ray has collided; it can't possibly find a closer collision now
        }
        minZ = maxZ;
        minY = maxY;
        minX = maxX;
    }
}
var inBox = function(x, y, z, w, h, d) {
    var iy = y - h/2 - p.topH;
    var ih = h + p.bottomH + p.topH;
    var ix = x - w/2 - p.w;
    var iw = w + p.w*2;
    var iz = z - d/2 - p.w;
    var id = d + p.w*2;
    return (p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id);
};
var boxCollision = function(x, y, z, w, h, d, vx, vy, vz, dt) {
    if(inBox(x, y, z, w, h, d)) {
        if(vx) {
            p.x -= p.velocity.x * dt;
            p.velocity.x = 0;
        }
        else if(vz) {
            p.z -= p.velocity.z * dt;
            p.velocity.z = 0;
        }
        else if(vy > 0) {
            p.y -= p.velocity.y * dt;
            p.velocity.y = 0;
        }
        else {
            p.y = (y - h/2 - p.topH) + (h + p.bottomH + p.topH);
            p.onGround = true;
            p.velocity.y = 0;
        }
    }
};
var contacts = {
    array: [],
    size: 0,
    add: function(x, y, z) {
        
        if (this.size === this.array.length) {
            this.array.push([x, y, z]);
        }
        else {
            this.array[this.size][0] = x;
            this.array[this.size][1] = y;
            this.array[this.size][2] = z;
        }
        this.size++;
    },
    clear: function() {
        this.size = 0;
    }
};
var resolveContactsAndUpdatePosition = function() {
    var minX = p2.x - 1;
    var maxX = p2.x + 1;
    var minY = p2.y - 2;
    var maxY = p2.y + 1;
    var minZ = p2.z - 1;
    var maxZ = p2.z + 1;
    var wrld = world;
    var cont = contacts;
    var block = null;
    var player = p;
    
    for (var x = minX; x <= maxX; x++) {
        for (var y = minY; y <= maxY; y++) {
            for (var z = minZ; z <= maxZ; z++) {
                if (wrld.getBlock(x, y, z)) {
                    cont.add(x, y, z);
                }
            }
        }
    }
    
    var dt = (win.performance.now() - p.lastUpdate) / 33;
    dt = dt > 2 ? 2 : dt;
    
    //Check collisions in the X direction
    player.x += player.velocity.x * dt;
    for (var i = 0; i < contacts.size; i++) {
        block = cont.array[i];
        boxCollision(block[0], block[1], block[2], 1, 1, 1, player.velocity.x, 0, 0, dt);
    }
    
    //Check collisions in the Y direction
    player.y += player.velocity.y * dt;
    for (var i = 0; i < contacts.size; i++) {
        block = cont.array[i];
        boxCollision(block[0], block[1], block[2], 1, 1, 1, 0, player.velocity.y, 0, dt);
    }
    
    //Check collisions in the Z direction
    player.z += player.velocity.z * dt;
    for (var i = 0; i < contacts.size; i++) {
        block = cont.array[i];
        boxCollision(block[0], block[1], block[2], 1, 1, 1, 0, 0, player.velocity.z, dt);
    }
    
    if (!p.flying) {
        var drag = p.onGround ? 0.5 : 0.85;
        var accz = p.velocity.z * drag - p.velocity.z;
        p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt;
        p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt;
    } else {
        var drag = 0.9;
        var accz = p.velocity.z * drag - p.velocity.z;
        p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt;
        p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt;
        p.velocity.y += (p.velocity.y * 0.8 - p.velocity.y) * dt;
        if (p.onGround) {
            p.flying = false;
        }
    }
    
    p.lastUpdate = win.performance.now();
    contacts.clear();
    lookingAt();
};
var runGravity = function() {
    if (p.flying) {
        return;
    }
    var dt = (win.performance.now() - p.lastUpdate) / 33;
    dt = dt > 2 ? 2 : dt;
    if(p.onGround) {
        if(Key[" "]) {
            p.velocity.y = p.jumpSpeed;
            p.onGround = false;
        }
        else {
            p.velocity.y = 0;
        }
    }
    else {
        p.velocity.y += p.gravityStength * dt;
        if(p.velocity.y < -p.maxYVelocity) {
            p.velocity.y = -p.maxYVelocity;
        }
    }
    p.onGround = false;
};

function box2(x, y, z, sides, tex) {
    var i = 0;
    for (var side in Block) {
        if (sides & Block[side]) {
            vertexAttribPointer("aVertex", programObject3D, "aVertex", 3, sideEdgeBuffers[Sides[side]]);
            if (blockFill) {
                vertexAttribPointer("aTexture", programObject3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]]); 
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0);
            }
            
            if (blockOutlines) {
                vertexAttribPointer("aTexture", programObject3D, "aTexture", 2, texCoordsBuffers[textureMap.hitbox]); 
                gl.drawArrays(gl.LINE_LOOP, 0, 4);
            }
        }
        if (i < 2) {
            i++;
        }
    }
}
function block(x, y, z, t) {
    box2(x, y, z, 0xff, blockData[t].textures);
}
function block2(x, y, z, t) {
    copyArr(modelView, matrix);
    trans(modelView, x, y, z);
    matMult();
    trans(modelView, -x, -y, -z);
    transpose(matrix);
    uniformMatrix("view3d", programObject3D, "uView", false, matrix);
    box2(x, y, z, 0xff, blockData[t].textures);
}

var changeWorldBlock = function(t) {
    var pos = hitBox.pos;
    if(pos && pos[1] > 0 && pos[1] < maxHeight) {
        world.setBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], t);
        if (t) {
            p.lastPlace = Date.now();
        } else {
            p.lastBreak = Date.now();
        }
    }
};
var newWorldBlock = function() {
    if(!hitBox.pos || !holding) {
        return;
    }
    var x = 0, y = 0, z = 0, pos = hitBox.pos;
    switch(hitBox.face) {
        case "top":
            y -= 1;
        break;
        case "bottom":
            y += 1;
        break;
        case "south":
            z -= 1;
        break;
        case "north":
            z += 1;
        break;
        case "west":
            x -= 1;
        break;
        case "east":
            x += 1;
        break;
    }
    if (!inBox(pos[0] + x, pos[1] + y, pos[2] + z, 1, 1, 1)) {
        pos[0] += x;
        pos[1] += y;
        pos[2] += z;
        changeWorldBlock(holding);
    }
};

var renderedChunks = 0;
function getBlock(x, y, z, blocks) {
    return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)] & 0xff;
}
function hideFace(x, y, z, blocks, type, func) {
    var block = func.call(world, x, y, z, blocks);
    var data = blockData[block]
    if (!block || block !== type && data.transparent || data.transparent && data.shadow) {
        return 1;
    }
    return 0;
}
var getShadows = {
    shade: [1, 0.85, 0.7, 0.6, 0.3],
    top: function(x, y, z, block) {
        var blocks = [
            blockData[getBlock(x-1, y-1, z-1, block)].shadow,
            blockData[getBlock(x, y-1, z-1, block)].shadow,
            blockData[getBlock(x+1, y-1, z-1, block)].shadow,
            blockData[getBlock(x-1, y-1, z, block)].shadow,
            blockData[getBlock(x, y-1, z, block)].shadow,
            blockData[getBlock(x+1, y-1, z, block)].shadow,
            blockData[getBlock(x-1, y-1, z+1, block)].shadow,
            blockData[getBlock(x, y-1, z+1, block)].shadow,
            blockData[getBlock(x+1, y-1, z+1, block)].shadow
        ];
        return [
            this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8,
            this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8,
            this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8,
            this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8
        ];
    },
    bottom: function(x, y, z, block) {
        var blocks = [
            blockData[getBlock(x-1, y+1, z-1, block)].shadow,
            blockData[getBlock(x, y+1, z-1, block)].shadow,
            blockData[getBlock(x+1, y+1, z-1, block)].shadow,
            blockData[getBlock(x-1, y+1, z, block)].shadow,
            blockData[getBlock(x, y+1, z, block)].shadow,
            blockData[getBlock(x+1, y+1, z, block)].shadow,
            blockData[getBlock(x-1, y+1, z+1, block)].shadow,
            blockData[getBlock(x, y+1, z+1, block)].shadow,
            blockData[getBlock(x+1, y+1, z+1, block)].shadow
        ];
        return [
            this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
            this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
            this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
            this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
        ];
    },
    north: function(x, y, z, block) {
        var blocks = [
            blockData[getBlock(x-1, y-1, z+1, block)].shadow,
            blockData[getBlock(x, y-1, z+1, block)].shadow,
            blockData[getBlock(x+1, y-1, z+1, block)].shadow,
            blockData[getBlock(x-1, y, z+1, block)].shadow,
            blockData[getBlock(x, y, z+1, block)].shadow,
            blockData[getBlock(x+1, y, z+1, block)].shadow,
            blockData[getBlock(x-1, y+1, z+1, block)].shadow,
            blockData[getBlock(x, y+1, z+1, block)].shadow,
            blockData[getBlock(x+1, y+1, z+1, block)].shadow
        ];
        return [
            this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
            this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
            this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
            this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
        ];
    },
    south: function(x, y, z, block) {
        var blocks = [
            blockData[getBlock(x-1, y-1, z-1, block)].shadow,
            blockData[getBlock(x-1, y, z-1, block)].shadow,
            blockData[getBlock(x-1, y+1, z-1, block)].shadow,
            blockData[getBlock(x, y-1, z-1, block)].shadow,
            blockData[getBlock(x, y, z-1, block)].shadow,
            blockData[getBlock(x, y+1, z-1, block)].shadow,
            blockData[getBlock(x+1, y-1, z-1, block)].shadow,
            blockData[getBlock(x+1, y, z-1, block)].shadow,
            blockData[getBlock(x+1, y+1, z-1, block)].shadow
        ];
        return [
            this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]],
            this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
            this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
            this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
        ];
    },
    east: function(x, y, z, block) {
        var blocks = [
            blockData[getBlock(x+1, y-1, z-1, block)].shadow,
            blockData[getBlock(x+1, y, z-1, block)].shadow,
            blockData[getBlock(x+1, y+1, z-1, block)].shadow,
            blockData[getBlock(x+1, y-1, z, block)].shadow,
            blockData[getBlock(x+1, y, z, block)].shadow,
            blockData[getBlock(x+1, y+1, z, block)].shadow,
            blockData[getBlock(x+1, y-1, z+1, block)].shadow,
            blockData[getBlock(x+1, y, z+1, block)].shadow,
            blockData[getBlock(x+1, y+1, z+1, block)].shadow
        ];
        return [
            this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8,
            this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8,
            this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8,
            this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8
        ];
    },
    west: function(x, y, z, block) {
        var blocks = [
            blockData[getBlock(x-1, y-1, z-1, block)].shadow,
            blockData[getBlock(x-1, y, z-1, block)].shadow,
            blockData[getBlock(x-1, y+1, z-1, block)].shadow,
            blockData[getBlock(x-1, y-1, z, block)].shadow,
            blockData[getBlock(x-1, y, z, block)].shadow,
            blockData[getBlock(x-1, y+1, z, block)].shadow,
            blockData[getBlock(x-1, y-1, z+1, block)].shadow,
            blockData[getBlock(x-1, y, z+1, block)].shadow,
            blockData[getBlock(x-1, y+1, z+1, block)].shadow
        ];
        return [
            this.shade[blocks[7] + blocks[8] + blocks[4] + blocks[5]]*0.8,
            this.shade[blocks[5] + blocks[4] + blocks[2] + blocks[1]]*0.8,
            this.shade[blocks[4] + blocks[3] + blocks[1] + blocks[0]]*0.8,
            this.shade[blocks[6] + blocks[7] + blocks[3] + blocks[4]]*0.8
        ];
    }
};

/** Section Class **/
{
var Section = function(x, y, z, size, chunk) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.size = size;
    this.arraySize = size * size * size;
    this.blocks = newInt32Array(this.arraySize);
    this.renderData = [];
    this.renderLength = 0;
    this.faces = 0;
    this.hasVisibleBlocks = false;
    this.chunk = chunk;
};
Section.prototype.getBlock = function(x, y, z) {
    var s = this.size;
    return this.blocks[x * s * s + y * s + z] & 0xff;
};
Section.prototype.setBlock = function(x, y, z, blockID, hidden) {
    var s = this.size;
    this.blocks[x * s * s + y * s + z] = !hidden << 31 | blockID;
};
Section.prototype.deleteBlock = function(x, y, z) {
    var s = this.size;
    var data = this.blocks[x * s * s + y * s + z];
    var index = this.renderData.indexOf(data);
    if (index >= 0 && index < this.renderLength) {
        this.renderData.splice(index, 1);
        this.renderLength--;
        this.hasVisibleBlocks = !!this.renderLength;
        if (!world.meshQueue.includes(this.chunk)) {
            world.meshQueue.push(this.chunk);
        }
    }
    this.blocks[x * s * s + y * s + z] = blockIds.air;
};
Section.prototype.optimize = function(world) {
    var visible = false;
    var pos = 0;
    var x = 0;
    var y = 0;
    var z = 0;
    var xx = this.x;
    var yy = this.y;
    var zz = this.z;
    var blockData = 0;
    var blockType = 0;
    var index = 0;
    var s = this.size;
    var blocks = this.blocks;
    this.hasVisibleBlocks = false;
    this.renderLength = 0;
    var localBlocks = world.getAdjacentSubchunks(xx, yy, zz);

    //Check all the blocks in the subchunk to see if they're visible.
    for (var i = 0; i < s; i++) {
        for (var j = 0; j < s; j++) {
            for (var k = 0; k < s; k++, index++) {
                blockData = blocks[index];
                if (blockData >= 0) {
                    continue;
                }
                blockType = blockData & 0xff;
                // x = i + xx;
                // y = j + yy;
                // z = k + zz;
                visible = (
                    hideFace(i-1, j, k, localBlocks, blockType, getBlock) |
                    hideFace(i+1, j, k, localBlocks, blockType, getBlock) << 1 |
                    hideFace(i, j-1, k, localBlocks, blockType, getBlock) << 2 |
                    hideFace(i, j+1, k, localBlocks, blockType, getBlock) << 3 |
                    hideFace(i, j, k-1, localBlocks, blockType, getBlock) << 4 |
                    hideFace(i, j, k+1, localBlocks, blockType, getBlock) << 5
                );
                if (visible) {
                    pos = (i | j << 4 | k << 8) << 16;
                    blockData = 1 << 31 | pos | visible << 8 | blockType;
                    this.renderData[this.renderLength++] = blockData;
                    blocks[index] = blockData;
                    this.hasVisibleBlocks = true;
                } else {
                    blocks[index] = blockType;
                }
            }
        }
    }
};
Section.prototype.updateBlock = function(x, y, z, world) {
    var i = x;
    var j = y;
    var k = z;
    var s = this.size;
    x += this.x;
    y += this.y;
    z += this.z;
    var blockData = this.blocks[i * s * s + j * s + k];
    var blockType = blockData & 0xff;
    var visible = blockType && (
        hideFace(x-1, y, z, 0, blockType, world.getBlock) |
        hideFace(x+1, y, z, 0, blockType, world.getBlock) << 1 |
        hideFace(x, y-1, z, 0, blockType, world.getBlock) << 2 |
        hideFace(x, y+1, z, 0, blockType, world.getBlock) << 3 |
        hideFace(x, y, z-1, 0, blockType, world.getBlock) << 4 |
        hideFace(x, y, z+1, 0, blockType, world.getBlock) << 5
    );
    var pos = (i | j << 4 | k << 8) << 16;
    var index = blockData < 0 ? this.renderData.indexOf(blockData) : -1;
    
    if ((index < 0 || index >= this.renderLength) && !visible) {
        if (!world.meshQueue.includes(this.chunk)) {
            world.meshQueue.push(this.chunk);
        }
        return;
    }
    if (!visible) {
        this.renderData.splice(index, 1);
        this.blocks[i * s * s + j * s + k] = blockType; //Toggle invisible bit
        this.renderLength--;
        this.hasVisibleBlocks = !!this.renderLength;
        if (!world.meshQueue.includes(this.chunk)) {
            world.meshQueue.push(this.chunk);
        }
        this.chunk.minY = y < this.chunk.minY ? y : this.chunk.minY;
        this.chunk.maxY = y > this.chunk.maxY ? y : this.chunk.maxY;
        return;
    }
    if (visible && (index < 0 || index >= this.renderLength)) {
        index = this.renderLength++;
        this.hasVisibleBlocks = true;
    }
    this.chunk.minY = y < this.chunk.minY ? y : this.chunk.minY;
    this.chunk.maxY = y > this.chunk.maxY ? y : this.chunk.maxY;
    this.renderData[index] = 1 << 31 | pos | visible << 8 | (blockData & 0xff);
    this.blocks[i * s * s + j * s + k] = this.renderData[index];
    if (!world.meshQueue.includes(this.chunk)) {
        world.meshQueue.push(this.chunk);
    }
};
Section.prototype.genMesh = function(barray, index) {
    if (!this.renderLength) {
        return index;
    }
    var length = this.renderLength;
    var rData = this.renderData;
    var x = 0, y = 0, z = 0, loc = 0, data = 0, sides = 0, tex = null, x2 = 0, y2 = 0, z2 = 0, verts = null, texVerts = null;
    var wx = this.x, wy = this.y, wz = this.z;
    var blocks = world.getAdjacentSubchunks(wx, wy, wz);
    
    var start = Date.now();
    var shadows = null;
    var bData = blockData;
    var gShadows = getShadows;
    var sedgeVerts = sideEdgeVerts;
    var tCoords = textureCoords;
    var tmap = textureMap;
    var block = Block;
    var sideMap = Sides;
    var blockSides = Object.keys(block);
    var side = "";
    for (var i = 0; i < length; i++) {
        data = rData[i];
        tex = bData[data & 0xff].textures;
        sides = data >> 8 & 0x3f;
        loc = data >> 16;
        x = loc & 15;
        y = loc >> 4 & 15;
        z = loc >> 8 & 15;
        
        x2 = x + this.x;
        y2 = y + this.y;
        z2 = z + this.z;
        
        var texNum = 0;
        for (var n = 0; n < 6; n++) {
            side = blockSides[n];
            if (sides & block[side]) {
                shadows = gShadows[side](x, y, z, blocks);
                verts = sedgeVerts[sideMap[side]];
                texVerts = tCoords[tmap[tex[texNum]]];
                
                barray[index] = verts[0] + x2;
                barray[index+1] = verts[1] + y2;
                barray[index+2] = verts[2] + z2;
                barray[index+3] = texVerts[0];
                barray[index+4] = texVerts[1];
                barray[index+5] = shadows[0];
                
                barray[index+6] = verts[3] + x2;
                barray[index+7] = verts[4] + y2;
                barray[index+8] = verts[5] + z2;
                barray[index+9] = texVerts[2];
                barray[index+10] = texVerts[3];
                barray[index+11] = shadows[1];
                
                barray[index+12] = verts[6] + x2;
                barray[index+13] = verts[7] + y2;
                barray[index+14] = verts[8] + z2;
                barray[index+15] = texVerts[4];
                barray[index+16] = texVerts[5];
                barray[index+17] = shadows[2];
                
                barray[index+18] = verts[9] + x2;
                barray[index+19] = verts[10] + y2;
                barray[index+20] = verts[11] + z2;
                barray[index+21] = texVerts[6];
                barray[index+22] = texVerts[7];
                barray[index+23] = shadows[3];
                index += 24;
            }
            if (texNum < 2) {
                texNum++;
            }
        }
    }
    return index;
};
}
function newSection(x, y, z, size, chunk) {
    var section = Object.create(Section.prototype);
    Section.apply(section, [x, y, z, size, chunk]);
    return section;
}
var emptySection = newSection(0, 0, 0, 16);

/** Chunk Class **/
{
var Chunk = function(x, z) {
    this.x = x;
    this.z = z;
    this.maxY = 0;
    this.minY = 255;
    this.sections = [];
    this.optimized = false;
    this.generated = false; //Terrain
    this.populated = false; //Trees
    this.lazy = false;
};
Chunk.prototype.getBlock = function(x, y, z) {
    var s = y >> 4;
    return this.sections.length > s ? this.sections[s].getBlock(x, y & 15, z) : 0;
};
Chunk.prototype.setBlock = function(x, y, z, blockID, hidden) {
    if (!hidden) {
        this.minY = y < this.minY ? y : this.minY;
        this.maxY = y > this.maxY ? y : this.maxY;
    }
    if (!this.sections[y >> 4]) {
        do {
            this.sections.push(newSection(this.x, this.sections.length * 16, this.z, 16, this));
        } while (!this.sections[y >> 4]);
    }
    this.sections[y >> 4].setBlock(x, y & 15, z, blockID, hidden);
};
Chunk.prototype.optimize = function(world) {
    for (var i = 0; i < this.sections.length; i++) {
        this.sections[i].optimize(world);
    }
    if (!world.meshQueue.includes(this)) {
        world.meshQueue.push(this);
    }
    this.optimized = true;
};
Chunk.prototype.render = function() {
    if (!this.buffer) {
        return;
    }
    if (chunkVisible(this.x, this.minY, this.z, this.maxY)) {
        renderedChunks++;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.vertexAttribPointer(glCache.locations.aVertex, 3, gl.FLOAT, false, 24, 0);
        gl.vertexAttribPointer(glCache.locations.aTexture, 2, gl.FLOAT, false, 24, 12);
        gl.vertexAttribPointer(glCache.locations.aShadow, 1, gl.FLOAT, false, 24, 20);
        gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0);
    }
};
Chunk.prototype.updateBlock = function(x, y, z, world, lazy) {
    this.lazy = lazy;
    if (this.sections.length > y >> 4) {
        this.sections[y >> 4].updateBlock(x, y & 15, z, world);
    }
};
Chunk.prototype.deleteBlock = function(x, y, z) {
    this.sections[y >> 4].deleteBlock(x, y & 15, z);
    this.minY = y < this.minY ? y : this.minY;
    this.maxY = y > this.maxY ? y : this.maxY;
};
Chunk.prototype.populate = function() {
    randomSeed(hash(this.x, this.z) * 210000000);
    var wx = 0, wz = 0, ground = 0, top = 0, rand = 0, place = false;
    for (var i = 0; i < 16; i++) {
        for (var k = 0; k < 16; k++) {
            wx = this.x + i;
            wz = this.z + k;
            ground = Math.round(noise(wx * generator.smooth, wz * generator.smooth) * generator.height);
            if (random() < 0.01) {
                
                top = ground + Math.floor(4.5 + random(2.5));
                rand = Math.floor(random(4096));
                var tree = random() < 0.6 ? blockIds.oakLog : (++top && blockIds.birchLog);
                
                //Center
                for (var j = ground + 1; j <= top; j++) {
                    this.setBlock(i, j, k, tree);
                }
                this.setBlock(i, top + 1, k, blockIds.leaves);
                this.setBlock(i, ground, k, blockIds.dirt);
                
                //Bottom leaves
                for (var x = -2; x <= 2; x++) {
                    for (var z = -2; z <= 2; z++) {
                        if (x || z) {
                            if ((x * z & 7) === 4) {
                                place = rand & 1;
                                rand >>>= 1;
                                if (place) {
                                    world.spawnBlock(wx + x, top - 2, wz + z, blockIds.leaves);
                                }
                            } else {
                                world.spawnBlock(wx + x, top - 2, wz + z, blockIds.leaves);
                            }
                        }
                    }
                }
                
                //2nd layer leaves
                for (var x = -2; x <= 2; x++) {
                    for (var z = -2; z <= 2; z++) {
                        if (x || z) {
                            if ((x * z & 7) === 4) {
                                place = rand & 1;
                                rand >>>= 1;
                                if (place) {
                                    world.spawnBlock(wx + x, top - 1, wz + z, blockIds.leaves);
                                }
                            } else {
                                world.spawnBlock(wx + x, top - 1, wz + z, blockIds.leaves);
                            }
                        }
                    }
                }
                
                //3rd layer leaves
                for (var x = -1; x <= 1; x++) {
                    for (var z = -1; z <= 1; z++) {
                        if (x || z) {
                            if (x & z) {
                                place = rand & 1;
                                rand >>>= 1;
                                if (place) {
                                    world.spawnBlock(wx + x, top, wz + z, blockIds.leaves);
                                }
                            } else {
                                world.spawnBlock(wx + x, top, wz + z, blockIds.leaves);
                            }
                        }
                    }
                }
                
                //Top leaves
                world.spawnBlock(wx + 1, top + 1, wz, blockIds.leaves);
                world.spawnBlock(wx, top + 1, wz - 1, blockIds.leaves);
                world.spawnBlock(wx, top + 1, wz + 1, blockIds.leaves);
                world.spawnBlock(wx - 1, top + 1, wz, blockIds.leaves);
            }

            // Blocks of each per chunk in Minecraft
            // Coal: 185.5
            // Iron: 111.5
            // Gold: 10.4
            // Redstone: 29.1
            // Diamond: 3.7
            // Lapis: 4.1
            ground -= 4;

            if (random() < 3.7 / 256) {
                var y = random() * 16 | 0 + 1;
                this.setBlock(i, y < ground ? y : ground, k, blockIds.diamondOre, true);
            }

            if (random() < 111.5 / 256) {
                var y = random() * ground | 0 + 1;
                this.setBlock(i, y < ground ? y : ground, k, blockIds.ironOre, true);
            }

            if (random() < 185.5 / 256) {
                var y = random() * ground | 0 + 1;
                this.setBlock(i, y < ground ? y : ground, k, blockIds.coalOre, true);
            }

            if (random() < 10.4 / 256) {
                var y = random() * 32 | 0 + 1;
                this.setBlock(i, y < ground ? y : ground, k, blockIds.goldOre, true);
            }

            if (random() < 29.1 / 256) {
                var y = random() * 32 | 0 + 1;
                this.setBlock(i, y < ground ? y : ground, k, blockIds.redstoneOre, true);
            }

            if (random() < 4.1 / 256) {
                var y = random() * 32 | 0 + 1;
                this.setBlock(i, y < ground ? y : ground, k, blockIds.lapisOre, true);
            }
        }
    }
    this.populated = true;
};
Chunk.prototype.genMesh = function() {
    var start = win.performance.now();
    var barray = bigArray;
    var index = 0;
    var g = gl;
    for (var i = 0; i < this.sections.length; i++) {
        index = this.sections[i].genMesh(barray, index);
    }
    var arrayDone = win.performance.now();
    
    if (!this.buffer) {
        this.buffer = g.createBuffer();
    }
    var data = barray.slice(0, index);
    this.faces = data.length / 24;
    g.bindBuffer(g.ARRAY_BUFFER, this.buffer);
    g.bufferData(g.ARRAY_BUFFER, data, g.DYNAMIC_DRAW);
    this.lazy = false;
    if (arrayDone - start > 3) {
        //console.log((arrayDone - start).toFixed(1), (win.performance.now() - arrayDone).toFixed(1), this.faces, this.sections.length);
    }
};
}
function newChunk(x, z) {
    var chunk = Object.create(Chunk.prototype);
    Chunk.apply(chunk, [x, z]);
    return chunk;
}

var analytics = {
    totalTickTime: 0,
    worstFrameTime: 0,
    totalRenderTime: 0,
    totalFrameTime: 0,
    lastUpdate: 0,
    frames: 1,
    displayedTickTime: "0",
    displayedRenderTime: "0",
    displayedFrameTime: "0",
    displayedwFrameTime: 0,
    fps: 0
};
function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
    var dx1 = p.x - c1.x - 8;
    var dy1 = p.z - c1.z - 8;
    var dx2 = p.x - c2.x - 8;
    var dy2 = p.z - c2.z - 8;
    return (dx1 * dx1 + dy1 * dy1) - (dx2 * dx2 + dy2 * dy2);
}
function optimizeLater(x, z) {
    var chunk = world.chunks[x] ? world.chunks[x][z] : null;
    if (chunk && chunk.buffer && !world.optimizeQueue.includes(chunk)) {
        world.optimizeQueue.push(chunk);
    }
}

/** World Class **/
{
var genChunk = function(chunk) {
    var one = Date.now();
    var x = chunk.x >> 4;
    var z = chunk.z >> 4;
    var trueX = chunk.x;
    var trueZ = chunk.z;

    if (chunk.generated) {
        return false;
    }
    var smoothness = generator.smooth;
    var hilliness = generator.height;
    var gen = 0;
    for (var i = 0; i < 16; i++) {
        for (var k = 0; k < 16; k++) {
            gen = Math.round(noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness);

            chunk.setBlock(i, gen, k, blockIds.grass);
            chunk.setBlock(i, gen - 1, k, blockIds.dirt);
            chunk.setBlock(i, gen - 2, k, blockIds.dirt);
            chunk.setBlock(i, gen - 3, k, blockIds.dirt);
            for (var j = 1; j < gen - 3; j++) {
                chunk.setBlock(i, j, k, blockIds.stone, true);
            }
            chunk.setBlock(i, 0, k, blockIds.bedrock, true);
        }
    }
    chunk.generated = true;
    generatedChunks++;
    
    optimizeLater(x + 1, z);
    optimizeLater(x - 1, z);
    optimizeLater(x, z + 1);
    optimizeLater(x, z - 1);
    //console.log(two - one, three - two, four - three, four - one);
    return true;
};
var getAdjacentSubchunks = function(x, y, z) {
    var minChunkX = (x - 16) >> 4;
    var maxChunkX = (x + 16) >> 4;
    var minChunkY = (y - 16) >> 4;
    var maxChunkY = (y + 16) >> 4;
    var minChunkZ = (z - 16) >> 4;
    var maxChunkZ = (z + 16) >> 4;
    var ret = [];
    for (x = minChunkX; x <= maxChunkX; x++) {
        for (var y = minChunkY; y <= maxChunkY; y++) {
            for (z = minChunkZ; z <= maxChunkZ; z++) {
                if (this.chunks[x] && this.chunks[x][z]) {
                    ret.push((this.chunks[x][z].sections[y] || emptySection).blocks);
                } else {
                    ret.push(emptySection.blocks);
                }
            }
        }
    }
    return ret;
};
var updateBlock = function(x, y, z, lazy) {
    if (this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4] && this.chunks[x >> 4][z >> 4].buffer) {
        this.chunks[x >> 4][z >> 4].updateBlock(x & 15, y, z & 15, this, lazy);
    }
};
var getWorldBlock = function(x, y, z) {
    if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
        return blockIds.air;
    }
    return this.chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15);
};
var getLoadedBlock = function(x, y, z) {
    var X = (x >> 4) + this.offsetX;
    var Z = (z >> 4) + this.offsetZ;
    if (y < 0 || y > maxHeight) {
        return blockIds.air;
    } else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
        return this.getWorldBlock(x, y, z);
    }
    return this.loaded[X * this.lwidth + Z].getBlock(x & 15, y, z & 15);
};
var setBlock = function(x, y, z, blockID, lazy) {
    if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
        return;
    }
    var chunk = this.chunks[x >> 4][z >> 4];
    
    if (blockID) {
        chunk.setBlock(x & 15, y, z & 15, blockID, false);
    } else {
        chunk.deleteBlock(x & 15, y, z & 15);
    }
    
    //Update the 6 adjacent blocks and 1 changed block
    this.updateBlock(x - 1, y, z, lazy);
    this.updateBlock(x + 1, y, z, lazy);
    this.updateBlock(x, y - 1, z, lazy);
    this.updateBlock(x, y + 1, z, lazy);
    this.updateBlock(x, y, z - 1, lazy); 
    this.updateBlock(x, y, z + 1, lazy);
    this.updateBlock(x, y, z, lazy);
    
    //Update the 8 corners so shadows in adjacent chunks update correctly
    this.updateBlock(x - 1, y - 1, z - 1, lazy);
    this.updateBlock(x + 1, y - 1, z - 1, lazy);
    this.updateBlock(x - 1, y - 1, z + 1, lazy);
    this.updateBlock(x + 1, y - 1, z + 1, lazy);
    this.updateBlock(x - 1, y + 1, z - 1, lazy);
    this.updateBlock(x + 1, y + 1, z - 1, lazy);
    this.updateBlock(x - 1, y + 1, z + 1, lazy);
    this.updateBlock(x + 1, y + 1, z + 1, lazy);
};
var spawnBlock = function(x, y, z, blockID) {
    //Sets a block anywhere without causing block updates around it. Only to be used in world gen.
    
    var chunkX = x >> 4;
    var chunkZ = z >> 4;
    if (!this.chunks[chunkX]) {
        this.chunks[chunkX] = [];
    }
    var chunk = this.chunks[chunkX][chunkZ];
    if (!chunk) {
        chunk = newChunk(chunkX * 16, chunkZ * 16);
        this.chunks[chunkX][chunkZ] = chunk;
    }
    if (chunk.buffer) {
        //Only used if spawning a block post-gen
        this.setBlock(x, y, z, blockID, true);
    } else if (!chunk.getBlock(x & 15, y, z & 15)) {
        chunk.setBlock(x & 15, y, z & 15, blockID, false);
    }
};
var tick = function() {
    var maxChunkX = (p.x >> 4) + renderDistance;
    var maxChunkZ = (p.z >> 4) + renderDistance;
    var chunk = maxChunkX + "," + maxChunkZ;
    if (chunk !== this.lastChunk) {
        this.lastChunk = chunk;
        this.loadChunks();
        this.chunkGenQueue.sort(sortChunks);
    }
    
    if (Key.leftMouse && p.lastBreak < Date.now() - 250) {
        changeWorldBlock(0);
    }
    if ((Key.rightMouse || Key.leftMouse && Key.control) && p.lastPlace < Date.now() - 250) {
        newWorldBlock();
    }
    if (Key.leftMouse && p.autoBreak && !Key.control) {
        changeWorldBlock(0);
    }
    
    var doneWork = false;
    if (this.meshQueue.length) {
        //If the player interacts with blocks, update all chunk meshes. Otherwise never update more than 1 per frame
        var len = this.meshQueue.length - 1;
        do {
            var chunk = this.meshQueue[len];
            if (chunk.lazy) {
                continue;
            }
            chunk.genMesh();
            this.meshQueue.splice(len, 1);
            doneWork = true;
            
        } while(len--);
        if (this.meshQueue.length && !doneWork) {
            this.meshQueue.pop().genMesh();
        }
        doneWork = true;
    }
    
    if (this.chunkGenQueue.length && !doneWork) {
        do {
            var chunk = this.chunkGenQueue[0];
            if (!chunk.generated) {
                this.genChunk(chunk);
            } else if (!chunk.populated) {
                chunk.populate();
            } else if (!chunk.optimized) {
                chunk.optimize(this);
            } else if (!chunk.buffer) {
                chunk.genMesh();
            } else {
                this.chunkGenQueue.shift();
                if(this.chunkGenQueue.length) {
                    continue;
                }
            }
            break;
        } while(this.chunkGenQueue.length);
        doneWork = !!this.chunkGenQueue.length;
    }
    if (this.optimizeQueue.length && !doneWork) {
        this.optimizeQueue.shift().optimize(this);
        doneWork = true;
    }
};
var render = function() {
    initModelView(p.x, p.y, p.z, p.rx, p.ry);
    
    p2.x = Math.round(p.x);
    p2.y = Math.round(p.y);
    p2.z = Math.round(p.z);
    
    renderedChunks = 0;
    gl.enableVertexAttribArray(glCache.locations.aShadow);
    
    var c = this.sortedChunks;
    var lx = p.direction.x;
    var ly = p.direction.y;
    var lz = p.direction.z;
    var nlx = lx < 0 ? 0 : 16;
    var nly = ly < 0;
    var nlz = lz < 0 ? 0 : 16;
    var x = p.x;
    var y = p.y;
    var z = p.z;
    var dx = 0, dy = 0, dz = 0;
    var chunk = null;
    for (var i = 0, l = c.length; i < l; i++) {
        chunk = c[i];
        dx = chunk.x - x + nlx;
        dy = (nly ? chunk.minY : chunk.maxY) - y;
        dz = chunk.z - z + nlz;
        if (dx * lx + dy * ly + dz * lz > 0) {
            chunk.render();
        }
    }
    
    if(hitBox.pos) {
        blockOutlines = true;
        blockFill = false;
        block2(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0);
        blockOutlines = false;
        blockFill = true;
    }
    gl.flush();
};
var loadChunks = function() {
    var minChunkX = (p.x >> 4) - renderDistance;
    var maxChunkX = (p.x >> 4) + renderDistance;
    var minChunkZ = (p.z >> 4) - renderDistance;
    var maxChunkZ = (p.z >> 4) + renderDistance;
    
    this.offsetX = -minChunkX;
    this.offsetZ = -minChunkZ;
    this.lwidth = renderDistance * 2 + 1;
    
    if (this.loaded.length > this.lwidth * this.lwidth) {
        this.loaded.length = this.lwidth * this.lwidth;
    }
    
    var i = 0;
    for (var x = minChunkX; x <= maxChunkX; x++) {
        for (var z = minChunkZ; z <= maxChunkZ; z++) {
            var chunk;
            if (!this.chunks[x]) {
                this.chunks[x] = [];
            }
            if (!this.chunks[x][z]) {
                chunk = newChunk(x * 16, z * 16);
                this.chunkGenQueue.push(chunk);
                this.chunks[x][z] = chunk;
            }
            chunk = this.chunks[x][z];
            if (!chunk.generated && !this.chunkGenQueue.includes(chunk)) {
                this.chunkGenQueue.push(chunk);
            }
            this.loaded[i++] = chunk;
        }
    }
    this.sortedChunks = this.loaded.slice();
    this.sortedChunks.sort(sortChunks);
};
}
function World() {
    //Initialize the world's arrays
    var loaded = [];
    var chunks = [];
    var queue = [];
    var lwidth = renderDistance * 2 + 1;
    var cx = renderDistance - (p.x >> 4);
    var cz = renderDistance - (p.z >> 4);
    var i = 0;
    for (var x = 0; x < lwidth; x++) {
        chunks[x - cx] = [];
        for (var z = 0; z < lwidth; z++) {
            var chunk = newChunk((x - cx) * 16, (z - cz) * 16);
            loaded[i++] = chunk;
            chunks[x - cx][z - cz] = chunk;
            queue.push(chunk);
        }
    }
    queue.sort(sortChunks);
    var sorted = queue.slice();
    return {
        chunks: chunks,
        loaded: loaded,
        sortedChunks: sorted,
        offsetX: cx,
        offsetZ: cz,
        lwidth: lwidth,
        chunkGenQueue: queue,
        optimizeQueue: [],
        meshQueue: [],
        renderDistance: renderDistance * 16,
        lastChunk: cx + "," + cz,
        
        genChunk: genChunk,
        getAdjacentSubchunks: getAdjacentSubchunks,
        updateBlock: updateBlock,
        getBlock: getLoadedBlock,
        getWorldBlock: getWorldBlock,
        setBlock: setBlock,
        spawnBlock: spawnBlock,
        tick: tick,
        render: render,
        loadChunks: loadChunks
    };
}

var defineWorld = function() {
    var tickStart = win.performance.now();
    world.tick();
    analytics.totalTickTime += win.performance.now() - tickStart;
    var renderStart = win.performance.now();
    world.render();
    analytics.totalRenderTime += win.performance.now() - renderStart;
};

var controls = function() {
    move.x = 0;
    move.z = 0;
    var dt = (win.performance.now() - p.lastUpdate) / 33;
    dt = dt > 2 ? 2 : dt;
    if(Key.w) {
        //move.z += cos(p.ry) * p.speed;
        //move.x -= sin(p.ry) * p.speed;
        move.z += p.speed;
    }
    if(Key.s) {
        //move.z -= cos(p.ry) * p.speed;
        //move.x += sin(p.ry) * p.speed;
        move.z -= p.speed;
    }
    if(Key.a) {
        //move.x += cos(p.ry) * p.speed;
        //move.z += sin(p.ry) * p.speed;
        move.x += p.speed;
    }
    if(Key.d) {
        //move.x -= cos(p.ry) * p.speed;
        //move.z -= sin(p.ry) * p.speed;
        move.x -= p.speed;
    }
    if (p.flying) {
        if(Key[" "]) {
            p.velocity.y += 0.06 * dt;
        }
        if(Key.shift) {
            p.velocity.y -= 0.06 * dt;
        }
    }
    if(Key.arrowleft) {
        p.ry -= 0.1 * dt;
    }
    if(Key.arrowright) {
        p.ry += 0.1 * dt;
    }
    if(Key.arrowup) {
        p.rx += 0.1 * dt;
    }
    if(Key.arrowdown) {
        p.rx -= 0.1 * dt;
    }
    
    if (Key.q) {
        p.sprinting = true;
    }
    
    if(p.sprinting) {
        move.x *= p.sprintSpeed;
        move.z *= p.sprintSpeed;
    }
    if(p.flying) {
        move.x *= p.flySpeed;
        move.z *= p.flySpeed;
    }
    if (!move.x && !move.z) {
        p.sprinting = false;
    }
    else if(Math.abs(move.x) > 0 && Math.abs(move.z) > 0) {
        move.x *= move.ang;
        move.z *= move.ang;
    }
    //Update the velocity, rather than the position.
    var co = Math.cos(p.ry);
    var si = Math.sin(p.ry);
    var friction = p.onGround ? 1 : 0.3;
    p.velocity.x += (co * move.x - si * move.z) * friction * dt;
    p.velocity.z += (si * move.x + co * move.z) * friction * dt;
    
    while(p.ry > Math.PI*2) {
        p.ry -= Math.PI*2;
    }
    while(p.ry < 0) {
        p.ry += Math.PI*2;
    }
    if(p.rx > Math.PI / 2) {
        p.rx = Math.PI / 2;
    }
    if(p.rx < -Math.PI / 2) {
        p.rx = -Math.PI / 2;
    }
    
    p.direction.set(-si * Math.cos(p.rx), Math.sin(p.rx), co * Math.cos(p.rx));
    computeFrustum();
};


var preventDefault = function(e) {
	e.preventDefault();
    if (e.deltaY > 0) {
        inventory.hotbarSlot++;
    } else if (e.deltaY < 0) {
        inventory.hotbarSlot--;
    }
    if (inventory.hotbarSlot > 8) {
        inventory.hotbarSlot = 0;
    } else if (inventory.hotbarSlot < 0) {
        inventory.hotbarSlot = 8;
    }
    
    updateHUD = true;
    holding = inventory.hotbar[inventory.hotbarSlot];
};

var keys = {32: 1, 37: 1, 38: 1, 39: 1, 40: 1};

function preventDefaultForScrollKeys(e) {
  if (keys[e.keyCode]) {
	e.preventDefault();
    return false;
  }
}

// modern Chrome requires { passive: false } when adding event
var supportsPassive = false;
try {
  window.addEventListener("test", null, Object.defineProperty({}, 'passive', {
    get: function () { supportsPassive = true; } 
  }));
} catch(e) {}

var wheelOpt = supportsPassive ? { passive: false } : false;
var wheelEvent = 'onwheel' in document.createElement('div') ? 'wheel' : 'mousewheel';

// call this to Disable
function disableScroll() {
  window.addEventListener('DOMMouseScroll', preventDefault, false); // older FF
  window.addEventListener(wheelEvent, preventDefault, wheelOpt); // modern desktop
  window.addEventListener('touchmove', preventDefault, wheelOpt); // mobile
  window.addEventListener('keydown', preventDefaultForScrollKeys, false);
}

disableScroll();

var buttons = [];
var button = function(x, y, w, h) {
    if(mouseX > x && mouseY > y && mouseX < x + w && mouseY < y + h) {
        return(true);
    }
    else {
        return(false);
    }
};
var addButton = function(x, y, w, h, text, callback, screen) {
    buttons.push({
        x: x,
        y: y,
        w: w,
        h: h,
        text: text,
        callback: callback,
        screen: screen
    });
};
var clickButton = function(button) {
    if (screen === button.screen && mouseX > button.x && mouseY > button.y && mouseX < button.x + button.w && mouseY < button.y + button.h) {
        button.callback();
    }
};
var drawButton = function(button) {
    if (screen === button.screen) {
        if (mouseX > button.x && mouseY > button.y && mouseX < button.x + button.w && mouseY < button.y + button.h) {
            strokeWeight(3);
            cursor(HAND);
        } else {
            strokeWeight(1);
        }
        ctx.strokeStyle = "black";
        ctx.fillStyle = "rgb(92, 92, 92)";
        ctx.rect(button.x, button.y, button.w, button.h);
		ctx.stroke();
		ctx.fill();
		ctx.beginPath();
        ctx.fillStyle = "black";
        textSize(35);
        ctx.font = '35px Sans-Serif';
		ctx.textAlign = 'center';
        ctx.fillText(button.text, button.x + button.w / 2, button.y + button.h / 2 + 10);
    }
};

var splashText = [
    "No easter eggs", "By ScusX & Willard!", "!sdrawkcaB", "var fun = true;", "Hey, you!", "Can render 400,000 blocks!", "Updates incoming", "No hidden fees!", "Hippopotamus!", "Gotta catch them all!", "Not greyscale", "9 + 10 = 21", "Someday...", "*SIGH*", "parseInt()", "get(rect());", "qwertyuiopasdfghjklzxcvbnm", "Nope.", "Sometimes, having a giant monitor is really helpful.", "igpay atinlay", "Five more minutes?", "Also try GameChiefCraft", "Also try Ultimate Platformer", "What's the opposite of right? Wrong!", "Feeling snackish? I know the feeling.", "Hey look! It's invisible!", "...", "Never trust semicolon closing parenthesis", ":D", ":P", "LG logo is pacman!", "Don't mine bedrock", "Cross-platform, if you build the platform", "Better than legos, not legolas"];
var splashSelect = Math.floor(random(0, splashText.length));
var textLength = splashText[splashSelect].length * 0.7;

var initEverything;
{
addButton(width / 2 - 150, height / 2 - 45, 300, 50, "Play", function() {
    play();
}, "main menu");
addButton(width / 2 - 150, height / 2 + 25, 300, 50, "Options", function() {
    screen = "options menu";
}, "main menu");
addButton(width / 2 - 150, 125, 300, 50, "Resume", function() {
    play();
}, "pause");
addButton(width / 2 - 150, 195, 300, 50, "Options", function() {
    screen = "pause options";
}, "pause");
addButton(width / 2 - 150, 265, 300, 50, "Exit to Main Menu", function() {
    textSize(12);
    splashSelect = Math.floor(random(0, splashText.length));
    textLength = splashText[splashSelect].length * 0.7;
    screen = "main menu";
}, "pause");
addButton(width / 2 - 150, 195, 300, 50, "Back", function() {
    screen = "main menu";
}, "options menu");
addButton(width / 2 - 150, 195, 300, 50, "Back", function() {
    screen = "pause";
}, "pause options");
} //Buttons

function initTextures() {
    var textureSize = 256;
    var texturePixels = newUint8Array(textureSize * textureSize * 4);
    textureMap = {};
    textureCoords = [];
    
    setPixel = function(textureNum, x, y, r, g, b, a) {
        var texX = textureNum & 15;
        var texY = textureNum >> 4;
        var offset = (texY * 16 + y) * 1024 + texX * 64 + x * 4;
        texturePixels[offset] = r;
        texturePixels[offset + 1] = g;
        texturePixels[offset + 2] = b;
        texturePixels[offset + 3] = a !== undefined ? a : 255;
    };
    getPixels = function(str) {
        proc = this; //Unrelated to this function
        
        var w = parseInt(str.substr(0, 2), 36);
        var h = parseInt(str.substr(2, 2), 36);
        var ccount = parseInt(str[4], 36);
        var colors = [];
        for (var i = 0; i < ccount; i++) {
            var num = parseInt(str.substr(5 + i * 7, 7), 36);
            colors.push([(num >>> 24) & 255, (num >>> 16) & 255, (num >>> 8) & 255, num & 255]);
        }
    
        var pixels = [];
        for (var i = 5 + ccount * 7; i < str.length; i++) {
            var num = parseInt(str[i], 36);
            pixels.push(colors[num][0], colors[num][1], colors[num][2], colors[num][3]);
        }
        return pixels;
    };
    
    
    (function() {
        //Specify the texture coords for each index
        for (var i = 0; i < 256; i++) {
            var texX = i & 15;
            var texY = i >> 4;
            var offsetX = texX * 0.0625;
            var offsetY = texY * 0.0625;
            textureCoords.push(newFloat32Array([0.0625 + offsetX, offsetY, offsetX, offsetY, offsetX, 0.0625 + offsetY, 0.0625 + offsetX, 0.0625 + offsetY]));
        }
        
        //Set all of the textures into 1 big tiled texture
        var n = 0;
        for (var i in textures) {
            if (typeof textures[i] === "function") {
                textures[i](n);
            } else if (typeof textures[i] === "string") {
                var pix = getPixels(textures[i]);
                for (var j = 0; j < pix.length; j += 4) {
                    setPixel(n, (j >> 2) & 15, j >> 6, pix[j], pix[j+1], pix[j+2], pix[j+3]);
                }
            }
            textureMap[i] = n;
            n++;
        }
        
        //Set the hitbox texture to 1 pixel
        for (var i = 0; i < 8; i += 2) {
            textureCoords[textureMap.hitbox][i] = textureCoords[textureMap.hitbox][2] + 0.01;
            textureCoords[textureMap.hitbox][i + 1] = textureCoords[textureMap.hitbox][1] + 0.01;
        }
    })();
    
    tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.activeTexture(gl.TEXTURE0);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.uniform1i(glCache.locations.uSampler, 0);
    
    genIcons();
}
function drawIcon(x, y, id) {
    x =  x / (3 * height) - 0.1666 * width / height;
    y = y / (3 * height) - 0.1666;
    initModelView(x, y, 0, 0, 0);
    
    var buffer = blockIcons[id];
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(glCache.locations.aVertex, 3, gl.FLOAT, false, 24, 0);
    gl.vertexAttribPointer(glCache.locations.aTexture, 2, gl.FLOAT, false, 24, 12);
    gl.vertexAttribPointer(glCache.locations.aShadow, 1, gl.FLOAT, false, 24, 20);
    gl.drawElements(gl.TRIANGLES, 6 * 3, gl.UNSIGNED_INT, 0);
}

function hotbar() {
    var before = currentFov;
    FOV(90);
    
    for(var i = 0; i < inventory.hotbar.length; i ++) {
        if(inventory.hotbar[i]) {
            var x = width / 2 - (inventory.hotbar.length / 2 * inventory.size) + (i + 0.5) * inventory.size + 25;
            var y = height - inventory.size;
            drawIcon(x, y, inventory.hotbar[i]);
        }
    }
    
    FOV(before);
}
function hud() {
    var s = inventory.size;
    var x = width / 2 + 0.5;
    var y = height / 2 + 0.5;
    
    ctx.lineWidth = 1;
    ctx.strokeStyle = "white";
    ctx.beginPath();
    
    ctx.moveTo(x - 10, y);
    ctx.lineTo(x + 10, y);
    ctx.moveTo(x, y - 10);
    ctx.lineTo(x, y + 10);
    ctx.stroke();
    
    //Hotbar
    x = width / 2 - (9 / 2 * s) + 0.5 + 25;
    y = height - s * 1.5 + 0.5;
    
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + s * 9, y);
    ctx.moveTo(x, y + s);
    ctx.lineTo(x + s * 9, y + s);
    for(var i = 0; i <= 9; i++) {
        ctx.moveTo(x + i * s, y);
        ctx.lineTo(x + i * s, y + s);
    }
    ctx.stroke();
    
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    ctx.beginPath();

    ctx.strokeRect(width / 2 - (9 / 2 * s) + inventory.hotbarSlot * s + 25, height - s * 1.5, s, s);
    
    var str = "Average Frame Time: " + analytics.displayedFrameTime + "ms\n" +
    "Worst Frame Time: " + analytics.displayedwFrameTime + "ms\n" +
    "Render Time: " + analytics.displayedRenderTime + "ms\n" +
    "Tick Time: " + analytics.displayedTickTime + "ms\n" +
    "Rendered Chunks: " + renderedChunks.toLocaleString() + " / " + world.loaded.length + "\n" +
    "Generated Chunks: " + generatedChunks.toLocaleString() + "\n" +
    "FPS: " + analytics.fps;
    
    if (p.autoBreak) {
        fastText("Super breaker enabled", 5, height - 89, 12);
    }
    
	ctx.textAlign = 'right';
    fastText(p2.x + ", " + p2.y + ", " + p2.z, width - 10, 15, 0);
	ctx.textAlign = 'left';
    fastText(str, 5, height - 77, 12);
}
function drawInv() {
    var x = 0;
    var y = 0;
    var s = inventory.size;
    var s2 = s / 2;
    var before = currentFov;
    var perRow = 13;
    
    //I don't know why, but this is barely transparent, so the gray bleeds through
    gl.clearColor(0.5, 0.5, 0.5, 0.0);
    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
    ctx.fillStyle = "rgb(30, 30, 30)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    FOV(90);
    
    // Draw the grid
    ctx.lineWidth = 1;
    ctx.strokeStyle = "black";
    ctx.beginPath();
    for (y = 0; y < 10; y++) {
        ctx.moveTo(50.5 - s2, 50.5 - s2 + y * s);
        ctx.lineTo(50.5 - s2 + s * perRow, 50.5 - s2 + y * s);
    }
    y--;
    for (x = 0; x < perRow + 1; x++) {
        ctx.moveTo(50.5 - s2 + s * x, 50.5 - s2);
        ctx.lineTo(50.5 - s2 + s * x, 50.5 - s2 + y * s);
    }
    
    // Hotbar
    x = width / 2 - (inventory.hotbar.length / 2 * s) + 0.5 + 25;
    y = height - s * 1.5 + 0.5;
    ctx.moveTo(x, y);
    ctx.lineTo(x + s * 9, y);
    ctx.moveTo(x, y + s);
    ctx.lineTo(x + s * 9, y + s);
    for(var i = 0; i <= inventory.hotbar.length; i ++) {
        ctx.moveTo(x + i * s, y);
        ctx.lineTo(x + i * s, y + s);
    }
    ctx.stroke();
    
    var overHot = (mouseX - x) / s | 0;
    if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
        x += s * overHot;
        ctx.lineWidth = 2;
        ctx.strokeStyle = "white";
        ctx.beginPath();
        ctx.strokeRect(x, y, s, s);
    }
    
    //Box highlight in inv
    var overInv = Math.round((mouseY - 50) / s) * perRow + Math.round((mouseX - 50) / s);
    if (overInv >= 0 && overInv < blockData.length - 1 && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
        x = (overInv % perRow) * s + 50 - s2;
        y = (overInv / perRow | 0) * s + 50 - s2;
        ctx.lineWidth = 2;
        ctx.strokeStyle = "white";
        ctx.beginPath();
        ctx.strokeRect(x, y, s, s);
    }
    
    if (inventory.holding) {
        drawIcon(mouseX, mouseY, inventory.holding);
    }
    for (var i = 1; i < blockData.length; i++) {
        x = ((i - 1) % perRow) * s + 50;
        y = ((i - 1) / perRow | 0) * s + 50;
        drawIcon(x, y, i);
    }
    
    hotbar();
    //hud();
    ctx.drawImage(gl.canvas, 0, 0);
    
    FOV(before);
}
function clickInv() {
    var s = inventory.size;
    var s2 = s / 2;
    var perRow = 13;
    var over = Math.round((mouseY - 50) / s) * perRow + Math.round((mouseX - 50) / s);
    var x = width / 2 - (9 / 2 * s) + 25;
    var y = height - s * 1.5;
    var overHot = (mouseX - x) / s | 0;
    if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
        var temp = inventory.hotbar[overHot];
        inventory.hotbar[overHot] = inventory.holding;
        inventory.holding = temp;
    }
    else if (over >= 0 && over < blockData.length - 1 && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
        inventory.holding = over + 1;
    }
    else {
        inventory.holding = 0;
    }
}

var unpauseDelay = 0;
function mmoved(e) {
    p.rx -= e.movementY / 300;
    p.ry += e.movementX / 300;
    
    while(p.ry > Math.PI*2) {
        p.ry -= Math.PI*2;
    }
    while(p.ry < 0) {
        p.ry += Math.PI*2;
    }
    if(p.rx > Math.PI / 2) {
        p.rx = Math.PI / 2;
    }
    if(p.rx < -Math.PI / 2) {
        p.rx = -Math.PI / 2;
    }
}
function trackMouse(e) {
    mouseX = e.x;
    mouseY = e.y;
}
doc.onmousemove = trackMouse;
doc.onpointerlockchange = function() {
    if (doc.pointerLockElement === canvas) {
        doc.onmousemove = mmoved;
    } else {
        doc.onmousemove = trackMouse;
        if (screen === "play" && !freezeFrame) {
            screen = "pause";
            unpauseDelay = Date.now() + 1000;
        }
    }
    for (var key in Key) {
        Key[key] = false;
    }
};
canvas.onmousedown = function(e) {
    mouseButton = [LEFT, 1, RIGHT][e.button];
    mouseX = e.x;
    mouseY = e.y;
    switch(e.button) {
        case 0:
            Key.leftMouse = true;
            break;
        case 1:
            Key.middleMouse = true;
            inventory.hotbar[inventory.hotbarSlot] = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]);
            break;
        case 2:
            Key.rightMouse = true;
            break;
    }
    if(screen === "play") {
        if (doc.pointerLockElement !== canvas) {
            getPointer();
            p.lastBreak = Date.now();
        } else {
            place = false;
            if(mouseButton === LEFT) {
                if(Key.control) {
                    place = true;
                }
                else {
                    changeWorldBlock(0);
                }
            }
            holding = inventory.hotbar[inventory.hotbarSlot];
            if(mouseButton === RIGHT && holding) {
                place = true;
            }
            if(place) {
                newWorldBlock();
            }
        }
    } else if (screen === "inventory") {
        clickInv();
    }
    else if(screen === "options menu") {
        if(button(0, 125, 50, 50)) {
            if(renderDistance > 1) {
                renderDistance--;
            }
        }
        if(button(width - 50, 125, 50, 50)) {
            renderDistance++;
        }
    }
    else if(screen === "pause options") {
        if(button(0, 125, 50, 50)) {
            if(renderDistance > 1) {
                renderDistance --;
            }
        }
        if(button(width - 50, 125, 50, 50)) {
            renderDistance ++;
        }
    }
    var currentScreen = screen;
    for (var i = 0; i < buttons.length; i++) {
        if (buttons[i].screen === currentScreen) {
            clickButton(buttons[i]);
        }
    }
};
canvas.onmouseup = function(e) {
    switch(e.button) {
        case 0:
            Key.leftMouse = false;
            break;
        case 1:
            Key.middleMouse = false;
            break;
        case 2:
            Key.rightMouse = false;
            break;
    }
};
doc.onkeydown = function(e) {
    if (e.repeat) {
        return;
    }
    var k = e.key.toLowerCase();
    Key[k] = true;
    if (k === "delete") {
        initEverything();
        releasePointer();
    }
    
    if (k === "t") {
        initTextures();
    }
    
    if (screen === "play") {
        if(k === "p") {
            releasePointer();
            screen = "pause";
        }
        
        if(k === "b") {
            p.autoBreak = !p.autoBreak;
        }
        
        if (k === " ") {
            if (Date.now() < p.lastJump + 400) {
                p.flying ^= true;
            } else {
                p.lastJump = Date.now();
            }
        }
        
        if (k === "z") {
            FOV(10);
        }
        
        if (k === "x") { //Quake Pro lol
            FOV(110);
        }
        
        if (k === "e") {
            screen = "inventory";
            releasePointer();
        }
        
        if (k === ";") {
            releasePointer();
            // ctx.clearRect(0, 0, canvas.width, canvas.height);
            // ctx.drawImage(gl.canvas, 0, 0);
            // hud();
            // updateHUD = false;
            freezeFrame = true;
            // analytics.lastUpdate = Date.now() + 10000;
        }
        
        if(Number(k)) {
            inventory.hotbarSlot = Number(k) - 1;
            holding = inventory.hotbar[inventory.hotbarSlot];
            updateHUD = true;
        }
    } else if (screen === "pause") {
        if(k === "p") {
            play();
        }
    } else if (screen === "inventory") {
        if (k === "e") {
			play();
        }
    }
    
};
doc.onkeyup = function(e) {
    var k = e.key.toLowerCase();
    Key[k] = false;
    if(k === "escape" && (screen.includes("pause") || screen === "inventory") && Date.now() > unpauseDelay) {
        play();
    }
    if (screen === "play") {
        if (k === "z") {
            FOV(fov);
        }
    }
};
canvas.onblur = function(e) {
    for (var key in Key) {
        Key[key] = false;
    }
};
canvas.oncontextmenu = function(e) {
	e.preventDefault();
}

var displaySplashText = function(x, y, r, w, n) {
    // if(n !== undefined) {
    //     textSize(12);
    //     textLength = textWidth(splashText[n]);
    // }
    // if(w / textLength * 40 > 45) {
    //     textSize(45);
    // }
    // else {
    //     textSize(w / textLength * 40);
    // }
    // textAlign(CENTER, CENTER);
    // pushMatrix();
    // translate(x, y);
    // rotate(r);
    // if(n === undefined) {
    //     text(splashText[splashSelect], 0, 0);
    // }
    // else {
    //     text(splashText[n], 0, 0);
    // }
    // popMatrix();
};

var backgroundImage;

function initEverything() {
    console.log("Initializing world.");
    
    worldSeed = random(2000000000);

    seedHash(worldSeed);
	noiseSeed(worldSeed);
    renderDistance = 4;
    generatedChunks = 0;
    
    screen = "main menu";
    p = {
        speed: 0.075,
        velocity: new PVector(0, 0, 0),
        direction: new PVector(0, 0, 0),
        sprintSpeed: 1.5,
        flySpeed: 2.5,
        x: 8,
        y: Math.round(noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2,
        z: 8,
        w: 3 / 8,
        bottomH: 1.62,
        topH: 0.18,
        rx: random(-0.5),
        ry: random(7),
        onGround: false,
        jumpSpeed: 0.3,
        sprinting: false,
        maxYVelocity: 1.5,
        gravityStength: -0.032,
        lastUpdate: win.performance.now(),
        lastBreak: Date.now(),
        lastPlace: Date.now(),
        lastJump: Date.now(),
        autoBreak: false,
        flying: false,
        frustum: []
    };
    for (var i = 0; i < 4; i++) {
        p.frustum[i] = new Plane();
    }
    world = World();
    
    if (!win.gl) {
        var canv = document.createElement('canvas');
		canv.width = ctx.canvas.width;
        canv.height = ctx.canvas.height;
		canv.style.position = "absolute";
        canv.style.zIndex = -1;
        canv.style.top = "0px";
        canv.style.left = "0px";
        // var ctxNames = ['experimental-webgl', 'webgl', 'webkit-3d'];
        // for (var i=0, l=ctxNames.length; i<l; i++) {
        //     gl = canv.getContext(ctxNames[i], {antialias: false});
        //     if (gl) {
        //         break;
        //     }
        // }
        gl = canv.getContext("webgl", {preserveDrawingBuffer: true, antialias: false});
        var ext = gl.getExtension('OES_element_index_uint');
        if (!ext) {
            alert("Please use a supported browser, or update your current browser.")
        }
        gl.viewport(0, 0, canv.width, canv.height);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        win.gl = gl;
    } else {
        gl = win.gl; 
    }

	if (!document.body.contains(gl.canvas)) {
        document.body.append(gl.canvas);
    }
    

    modelView = newFloat32Array(16);
    glCache = { attributes: {}, locations: {} };
    programObject3D = createProgramObject(gl, vertexShaderSrc3D, fragmentShaderSrc3D);
    gl.useProgram(programObject3D);
    glCache.locations.uEdge = gl.getUniformLocation(programObject3D, "uEdge");
    glCache.locations.uSampler = gl.getUniformLocation(programObject3D, "uSampler");
    glCache.locations.aShadow = gl.getAttribLocation(programObject3D, "aShadow");
    
    //Send the block textures to the GPU
    initTextures();
    
    sideEdgeBuffers = {};
    for (var side in sideEdgeVerts) {
        var edgeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, sideEdgeVerts[side], gl.STATIC_DRAW);
        sideEdgeBuffers[side] = edgeBuffer;
    }
    texCoordsBuffers = [];
    for (var t in textureCoords) {
        var buff = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buff);
        gl.bufferData(gl.ARRAY_BUFFER, textureCoords[t], gl.STATIC_DRAW);
        texCoordsBuffers.push(buff);
    }
    
    //Bind the Vertex Array Object (VAO) that will be used to draw everything
    indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexOrder, gl.STATIC_DRAW);
    
    //Tell it not to render the insides of blocks
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    
    gl.disableVertexAttribArray(glCache.locations.aShadow);
    gl.vertexAttrib1f(glCache.locations.aShadow, 1.0);
    gl.lineWidth(2);
    blockOutlines = false;
    gl.enable(gl.POLYGON_OFFSET_FILL);
    gl.polygonOffset(1, 1);
    gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
    
    FOV(60);
    var HALF_PI = Math.PI / 2;
    initModelView(0, 0, 0, -HALF_PI / 6, -HALF_PI / 2.5);
    
    block2(1, -1, 5, 1);
    block2(2, -1, 5, 1);
    block2(3, -2, 4, 1);
    block2(3, -2, 5, 1);
    block2(2, -2, 4, 1);
    block2(1, -2, 4, 1);
    block2(0, -3, 4, 1);
    block2(1, -3, 4, 2);
    block2(1, -4, 3, 1);
    block2(2, -3, 3, 1);
    block2(3, -2, 3, 1);
    block2(3, -3, 2, 1);
    block2(5, -3, 2, 1);
    block2(4, -4, 1, 1);
    block2(4, -3, 2, 1);
    block2(0, -2, 5, 1);
    block2(4, -2, 3, 1);
    block2(4, -2, 4, 1);
    block2(5, -3, 3, 1);
    //ctx.drawImage(gl.canvas, 0, 0);
    FOV(fov);
}

var gameLoop = function() {
    var frameStart = win.performance.now();
    if (!screen) {
        initEverything();
        releasePointer();
    }
    
    if(screen.includes("menu")) {
        cursor(CROSS);
        strokeWeight(1);
        ctx.clearRect(0, 0, width, height);
        fill(0, 0, 0);
        textSize(75);
		ctx.textAlign = 'center';
        text("Minecraft", width / 2, 100);
        
        if(screen === "main menu") {
            fill(51, 51, 51);
            displaySplashText(width / 2, 115, 0, 100);
            fill(0, 0, 0);
            textSize(20);
			ctx.textAlign = 'right';
            text("Version " + version, width - 10, height - 10);
        }
        else if(screen === "options menu") {
            ctx.beginPath();
			ctx.strokeStyle = "black";
        	ctx.fillStyle = "rgb(92, 92, 92)";
			strokeWeight(2);
			ctx.rect(width / 2 - 150, 125, 300, 50);
			ctx.stroke();
			ctx.fill();
            fill(0, 0, 0);
            textSize(30);
			ctx.textAlign = 'center';
            text("Render Distance: " + renderDistance, width / 2, 160);
            strokeWeight(7);
            stroke(255, 255, 255);
			ctx.beginPath();
            line(10, 150, 40, 150);
            line(width - 10, 150, width - 40, 150);
            line(width - 25, 135, width - 25, 165);
			ctx.stroke();
			ctx.beginPath();
        }
        currentFont = "";
    }
    else if(screen === "play") {
        controls();
        runGravity();
        resolveContactsAndUpdatePosition();
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
        hotbar();
        defineWorld(); // Draw world (among other things)
        //ctx.drawImage(gl.canvas, 0, 0);
        
        if (updateHUD) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            hud();
            updateHUD = false;
            freezeFrame = false;
        }
    } else if (screen === "inventory") {
        drawInv();
    }
    else if(screen.includes("pause")) {
        cursor(CROSS);
        strokeWeight(1);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(gl.canvas, 0, 0);
        
        // fill(0, 0, 0, 100);
        // rect(-2, -2, width + 4, height + 4);
        
        textSize(60);
        fill(0, 0, 0);
		ctx.textAlign = 'center';
        text("Paused", width / 2, 60);
        if(screen === "pause options") {
			ctx.beginPath();
			ctx.strokeStyle = "black";
        	ctx.fillStyle = "rgb(92, 92, 92)";
			strokeWeight(2);
			ctx.rect(width / 2 - 150, 125, 300, 50);
			ctx.stroke();
			ctx.fill();
            fill(0, 0, 0);
            textSize(30);
            text("Render Distance: " + renderDistance, width / 2, 160);
            strokeWeight(7);
            stroke(255, 255, 255);
			ctx.beginPath();
            line(10, 150, 40, 150);
            line(width - 10, 150, width - 40, 150);
            line(width - 25, 135, width - 25, 165);
			ctx.stroke();
			ctx.beginPath();
        }
        currentFont = "";
    }
    buttons.forEach(drawButton);

    if (Date.now() - analytics.lastUpdate > 500 && analytics.frames) {
        analytics.displayedTickTime = (analytics.totalTickTime / analytics.frames).toFixed(1);
        analytics.displayedRenderTime = (analytics.totalRenderTime / analytics.frames).toFixed(1);
        analytics.displayedFrameTime = (analytics.totalFrameTime / analytics.frames).toFixed(1);
        analytics.fps = Math.round(analytics.frames * 1000 / (Date.now() - analytics.lastUpdate));
        analytics.displayedwFrameTime = analytics.worstFrameTime.toFixed(1);
        //1000 / analytics.worstFrameTime
        analytics.frames = 0;
        analytics.totalRenderTime = 0;
        analytics.totalTickTime = 0;
        analytics.totalFrameTime = 0;
        analytics.worstFrameTime = 0;
        analytics.lastUpdate = Date.now();
        updateHUD = true;
    }

    analytics.frames++;
    analytics.totalFrameTime += win.performance.now() - frameStart;
    analytics.worstFrameTime = Math.max(win.performance.now() - frameStart, analytics.worstFrameTime);
    window.parent.raf = window.requestAnimationFrame(gameLoop);
};
return gameLoop;
})();
if (window.parent.raf) {
    window.cancelAnimationFrame(window.parent.raf);
    console.log("Canceled", window.parent.raf)
}
init();


    </script>
    </body>
</html>
